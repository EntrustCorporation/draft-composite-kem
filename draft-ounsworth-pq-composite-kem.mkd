---
title: Composite KEM For Use In Internet PKI
abbrev: PQ Composite Keys
docname: draft-ounsworth-pq-composite-kem-01

# <!-- stand_alone: true -->
ipr: trust200902
area: Security
wg: LAMPS
kw: Internet-Draft
cat: std

coding: us-ascii
pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:
    -
      ins: M. Ounsworth
      name: Mike Ounsworth
      org: Entrust Limited
      abbrev: Entrust
      street: 2500 Solandt Road – Suite 100
      city: Ottawa, Ontario
      country: Canada
      code: K2K 3G5
      email: mike.ounsworth@entrust.com

    -
      ins: J. Gray
      name: John Gray
      org: Entrust Limited
      abbrev: Entrust
      email: john.gray@entrust.com

normative:
  RFC1421:
  RFC2119:
  RFC2986:
  RFC4210:
  RFC5280:
  RFC5652:
  RFC5912:
  RFC5914:
  RFC5958:
  RFC7468:
  RFC8174:
  RFC8411:
  RFC8702:
  I-D.draft-ietf-lamps-kyber-certificates-00:
  I-D.draft-ounsworth-pq-composite-keys-01:
  I-D.draft-perret-prat-lamps-cms-pq-kem-00:
  SHA3:
    title: "SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions, FIPS PUB 202, DOI 10.6028/NIST.FIPS.202"
    author: 
      org: "National Institute of Standards and Technology (NIST)"
    date: August 2015
    target: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf
  X.690:
      title: "Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)"
      date: November 2015
      author:
        org: ITU-T
      seriesinfo:
        ISO/IEC: 8825-1:2015
  SEC1:
    title: "Standards for Efficient Cryptography Group, SEC1: Elliptic Curve Cryptography"
    date: "May 2009"
    target: <https://www.secg.org/sec1-v2.pdf>


# <!-- EDNOTE: full syntax for this defined here: https://github.com/cabo/kramdown-rfc2629 -->

informative:
  RFC3279:
  RFC5639:
  RFC5990:
  RFC6090:
  RFC7296:
  RFC7748:
  RFC8446:
  RFC8551:
  I-D.draft-ounsworth-pq-composite-sigs-07:
  I-D.draft-ietf-tls-hybrid-design-04:
  I-D.draft-becker-guthrie-noncomposite-hybrid-auth-00:
  I-D.draft-ounsworth-cfrg-kem-combiners-00:
  I-D.draft-driscoll-pqt-hybrid-terminology-01:
  Bindel2017:
    title: "Transitioning to a quantum-resistant public key infrastructure"
    target: "https://link.springer.com/chapter/10.1007/978-3-319-59879-6_22"
    author:
      -
        ins: N. Bindel
        name: Nina Bindel
      -
        ins: U. Herath
        name: Udyani Herath
      -
        ins: M. McKague
        name: Matthew McKague
      -
        ins: D. Stebila
        name: Douglas Stebila
    date: 2017
  Aviram2022:
    title: "Practical (Post-Quantum) Key Combiners from One-Wayness and Applications to TLS."
    target: "https://eprint.iacr.org/2022/065"
    author:
      -
        ins: 
  Aviram2021:
    title: "Concatenating Secrets May Be Dangerous"
    target: "https://github.com/nimia/kdf_public"
    Author:
      -
        ins: N. Aviram
        name: Nimrod Aviram
      - 
        ins: B. Dowling
        name: Benjamin Dowling
      - 
        ins: Komargodski
        name: Ilan Komargodski
      - 
        ins: Paterson
        name: Kenneth G Paterson
      - 
        ins: Ronen
        name: Eyal Ronen
      -
        ins: Yogev
        name: Eylon Yogev
    date: 2022




--- abstract

The migration to post-quantum cryptography is unique in the history of modern digital cryptography in that neither the old outgoing nor the new incoming algorithms are fully trusted to protect data for the required data lifetimes. The outgoing algorithms, such as RSA and elliptic curve, may fall to quantum cryptalanysis, while the incoming post-quantum algorithms face uncertainty about both the underlying mathematics as well as hardware and software implementations that have not had sufficient maturing time to rule out classical cryptanalytic attacks and implementation bugs.

Cautious implementers may wish to layer cryptographic algorithms such that an attacker would need to break all of them in order to compromise the data being protected using either a Post-Quantum / Traditional Hybrid, Post-Quantum / Post-Quantum Hybrid, or combinations thereof. This document, and its companions, defines a specific instantiation of hybrid paradigm called "composite" where multiple cryptographic algorithms are combined to form a single key, signature, or key encapsulation mechanism (KEM) such that they can be treated as a single atomic object at the protocol level.


This document defines the structure CompositeCiphertextValue which is a sequence of the respective ciphertexts for each component algorithm. Explicit pairings of algorithms are defined which should meet most Internet needs. The generic composite key type is also defined which allows arbitrary combinations of key types to be placed in the CompositePublicKey and CompositePrivateKey structures without needing the combination to be pre-registered or pre-agreed. For the purpose of combining KEMs, the combiner function from {{I-D.ounsworth-cfrg-kem-combiners}} is used.


This document is intended to be coupled with the composite keys
structure define in {{I-D.ounsworth-pq-composite-keys}} and the CMS KEM-TRANS mechanism in {{I-D.perret-prat-lamps-cms-pq-kem}}.


<!-- End of Abstract -->


--- middle

# Changes in version -01

* Sycronized terminology with I-D.draft-driscoll-pqt-hybrid-terminology-01.

# Introduction {#sec-intro}

During the transition to post-quantum cryptography, there will be uncertainty as to the strength of cryptographic algorithms; we will no longer fully trust traditional cryptography such as RSA, Diffie-Hellman, DSA and their elliptic curve variants, while we may also not fully trust their post-quantum replacements until they have had sufficient scrutiny and time to discover and fix implementation bugs. Unlike previous cryptographic algorithm migrations, the choice of when to migrate and which algorithms to migrate to, is not so clear. Even after the migration period, it may be advantageous for an entity's cryptographic identity to be composed of multiple public-key algorithms.

The deployment of composite public keys and composite encryption using post-quantum algorithms will face two challenges


- Algorithm strength uncertainty: During the transition period, some post-quantum signature and encryption algorithms will not be fully trusted, while also the trust in legacy public key algorithms will start to erode.  A relying party may learn some time after deployment that a public key algorithm has become untrustworthy, but in the interim, they may not know which algorithm an adversary has compromised.
- Migration: During the transition period, systems will require mechanisms that allow for staged migrations from fully classical to fully post-quantum-aware cryptography.


This document provides a mechanism to address algorithm strength uncertainty by building on {{I-D.ounsworth-pq-composite-keys}} by providing the format and process for combining multiple cryptographic algorithms into a single key encapsulation operation. Backwards compatibility is not directly covered in this document, but is the subject of {{sec-backwards-compat}}.


This document is intended for general applicability anywhere that key establishment or enveloped content encryption is used within PKIX or CMS structures.



<!-- End of Introduction section -->


## Terminology {#sec-terminology}
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 {{RFC2119}}  {{RFC8174}} when, and only when, they appear in all capitals, as shown here.

This document is consistent with all terminology from {{I-D.driscoll-pqt-hybrid-terminology}}.

In addition, the following terms are used in this document:


BER:
          Basic Encoding Rules (BER) as defined in [X.690].

CLIENT:
          Any software that is making use of a cryptographic key.
          This includes a signer, verifier, encrypter, decrypter.

COMBINER:
          A combiner specifies how multiple shared secrets
          are combined into a single shared secret.
DER:
          Distinguished Encoding Rules as defined in [X.690].

KEM:
        A key encapsulation mechanism as defined in {{sec-kems}}.

PKI:
          Public Key Infrastructure, as defined in [RFC5280].

SHARED SECRET:
        A value established between two communicating parties for use as cryptographic key material, but which cannot be learned by an active or 
        passive adversary. This document is concerned with shared secrets established via public key cryptagraphic operations.


# Composite KEM Structures

## Key Encapsulation Mechanisms (KEMs) {#sec-kems}

We borrow here the definition of a key encapsulation mechanism (KEM) from {{I-D.ietf-tls-hybrid-design}}, in which a KEM is a cryptographic primitive that consists of three algorithms:

   *  KeyGen() -> (pk, sk): A probabilistic key generation algorithm,
      which generates a public key pk and a secret key sk.

   *  Encaps(pk) -> (ct, ss): A probabilistic encapsulation algorithm,
      which takes as input a public key pk and outputs a ciphertext ct
      and shared secret ss.

   *  Decaps(sk, ct) -> ss: A decapsulation algorithm, which takes as
      input a secret key sk and ciphertext ct and outputs a shared
      secret ss, or in some cases a distinguished error value.


This document is not concerned with the KeyGen() algorithm of a KEM, but it is included above for completeness.

The KEM interface defined above differs from both traditional key transport mechanism (for example for use with KeyTransRecipientInfo defined in {{RFC5652}}), and key agreement (for example for use with KeyAgreeRecipientInfo defined in {{RFC5652}}). 

The KEM interface was chosen as the interface for a composite key exchange because it allows for arbitrary combinations of component algorithm types since both key transport and key agreement mechanisms can be promoted into KEMs in the following ways:

A key transport mechanism can be transformed into a KEM.Encaps(pk) by generating a random shared secret ss and performing KeyTrans.Encrypt(pk, ss) -> ct; and into a KEM.Decaps(sk, ct) by KeyTrans.Decrypt(sk, ct) -> ss. This follows the pattern of RSA-KEM [RFC5990].

A key agreement mechanism can be transformed into a KEM.Encaps(pk) by generating an ephemeral key pair (pk_e, sk_e), and performing KeyAgree(pk, sk_e) -> (ss, pk_e); and into a KEM.Decaps(sk, ct) by completing the key agreement as KeyAgree(pk_e, sk) -> ss.

A composite KEM allows two or more underlying key transport, key agreement, or KEM algorithms to be combined into a single cryptographic operations by performing each operation, transformed to a KEM as outline above, and using a specified combiner function to combine the two or more component shared secrets into a single shared secret.



The main security property for KEMs is indistinguishability under
adaptive chosen ciphertext attack (IND-CCA2), which means that shared
secret values should be indistinguishable from random strings even
given the ability to have other arbitrary ciphertexts decapsulated.

EDNOTE: it would be really nice for security proofs if definition of KEM included that the bits of the shared secret output need to be uniformly distributed (ie IND-CCA), because for example it would then be safe to XOR or truncate them. While the NIST PQC candidates all seem to do this, we could not find a definition of "KEM" that includes it as a requirement.


A weaker security notion is indistinguishability under chosen
plaintext attack (IND-CPA), which means that the shared secret values
should be indistinguishable from random strings given a copy of the
public key.  IND-CPA roughly corresponds to security against a
passive attacker, and sometimes corresponds to one-time key exchange.

The composite KEM mechanisms meets these security properties if and only if the component primitives meet them.

TODO: needs more formal analysis that the methods of transforming KeyTrans and KeyAgree meet this.

EDNOTE:  Discussed use of ASN.1 to combine the shared secrets. ASN.1 is nice because it embeds the length values for
us. Decided instead to run each component shared secret through the supplied KDF which will normalize all the lengths.

## Composite Keys

A composite key is a single key object that performs an atomic cryptographic operation as
defined in {{I-D.ounsworth-pq-composite-keys}}.

### Key Usage Bits

When using composite KEM keys in a structure which defines a key usage (such as in an 
X509Certificate as defined in [RFC5280]), the following key usage MUST be used.

~~~
  keyEncipherment
~~~
   
Additional key usages SHOULD not be used.

EDNOTE:  The main argument for using keyEncipherment verses keyAgreement is that multiple 
parties are required to contribute to a key agreement verses a single party in keyEncipherment. 

EDNOTE:  It is recognized that KEMS will be added into other PKIX and X509 standards and LAMPS needs to make sure they all make the same choice about the key usage of a KEM key. 


## CompositeCiphertextValue {#sec-CompositeCiphertextValue}

The compositeCipherTextValue is a concatenation of the ciphertexts of the
underlying component algorithms.  It is represented in ASN.1 as follows:

~~~
CompositeCiphertextValue ::= SEQUENCE SIZE (2..MAX) OF BIT STRING
~~~

## Encoding Rules

Many protocol specifications will require that composite KEM data structures be represented by an octet string or bit string.

When an octet string is required, the DER encoding of the composite data structure SHALL be used directly.

EDNOTE: will this definition include an ASN.1 tag and length byte inside the OCTET STRING object? If so, that's probably an extra unnecessary layer.

When a bit string is required, the octets of the DER encoded composite data structure SHALL be used as the bits of the bit string, with the most significant bit of the first octet becoming the first bit, and so on, ending with the least significant bit of the last octet becoming the last bit of the bit string.

In the interests of simplicity and avoiding compatibility issues, implementations that parse these structures MAY accept both BER and DER.

## KEM Combiner

This document follows the advice of {{I-D.ounsworth-cfrg-kem-combiners}}: the outputs of multiple KEMs are combined as

~~~
KDF( H(ss1) || H(ss2) )
~~~

where the inner hash on `H(ss1)` and `H(ss2)` are optional if the component KEMs use a KDF internally when producing its output.

Each registered composite KEM algorithm must specify the exact KEM combiner construction that is to be used.



# Algorithm Identifiers {#sec-alg-ids}

This section defines algorithm identifiers, component algorithms and their ordering for composite combinations. The combinations registered in this section are intended to strike a balance between the overall number of combinations ("the combinatorial explosion problem"), while also covering the needs of a wide range of protocols, applications, and regulatory environments in which X.509-based technologies are used. 

This section is not intended to be exhaustive and other authors may define OIDs for new combinations so long as they are compatible with the structures and processes defined in this and the companion signature and encryption documents.


KEM type                           | Definition                                   | OID
---------                          | -----------                                  | ----------
id-kem-Kyber512-ECDH-P256-SHAKE128 | {{sec-id-kem-Kyber512-ECDH-P256-SHAKE128}}   | TBD
id-Kyber512-EC-brainpoolP256r1     | TODO                                         | TBD
id-Kyber512-X25519                 | TODO                                         | TBD
id-Kyber768-RSA                    | TODO                                      | TBD
id-Kyber768-EC-P256                | TODO                                      | TBD
id-Kyber768-EC-brainpoolP256r1     | TODO                                      | TBD
id-Kyber768-X25519                 | TODO                                      | TBD
id-Kyber1024-EC-P384               | TODO                                      | TBD
id-Kyber1024-EC-brainpoolP384r1    | TODO                                      | TBD
id-Kyber1024-X448                  | TODO                                      | TBD
id-composite-key                   | {{sec-generic-composite}}                 | TBD
{: #tab-kem-agls title="Composite KEM key types"}



These combinations were chosen according to the following rough guidelines:

1. One RSA combination is provided (but RSA modulus size not mandated), matched with NIST PQC Level 3 algorithms.
1. NIST [RFC6090], Edwards [RFC7748], and Brainpool [RFC5639] elliptic curve algorithms are provided. NIST PQC Levels 1 - 3 algorithms are matched with 256-bit curves, while NIST levels 4 - 5 are matched with 384-bit elliptic curves. This provides a balance between matching classical security levels of post-quantum and traditional algorithms, and also selecting elliptic curves which already have wide adoption.
1. NIST level 1 candidates (Kyber512) are provided, matched with 256-bit elliptic curves, intended for constrained use cases.
1. A generic composite OID is provided for implementers who wish to use combinations not listed here, without the overhead of defining new OIDs. Caution should be exercised to avoid issues with compatibility and complex cryptographic policy mechanisms.

The authors wish to note that although the CompositePublicKey and CompositePrivateKey structures are defined in such a way as to easily allow 3 or more component keys, it was decided at the time of writing to only specify explicit pairs. The generic composite specified in {{sec-generic-composite}} of course allows for an arbitrary number of components. This also does not preclude future specification of explicit combinations with three or more components.


## id-kem-Kyber512-ECDH-P256-SHAKE128 {#sec-id-kem-Kyber512-ECDH-P256-SHAKE128}

This compasite KEM algorithm MAY be used with a `id-Kyber512-EC-P256` as defined in {{I-D.ounsworth-pq-composite-keys}}, or MAY be used with Kyber512 and EC P256 keys from independant sources.


The first componet BIT STRING within `CompositeCiphertextValue` SHALL be the ciphertext output of the Kyber512 algorithm as per TODO: cite NIST FIPS spec. `ss1` SHALL be the encpasulated shared secret corresponding to the first ciphertext.


The second componet BIT STRING within `CompositeCiphertextValue` SHALL be the ciphertext output of the ECDH algorithm on the NIST P-256 curv as per TODO: cite NIST FIPS spec... WHICH ONE? NIST.SP.800-56Ar3? SEC1? THERE ARE A NUMBER OF DIFFERENT ALGS IN THERE I GUESS WE NEED TO CHOOSE ONE. `ss2` SHALL be the encpasulated shared secret corresponding to the second ciphertext.

EDNOTE: check that the chosen ECDH does in fact use a KDF to compute its output, otherwise we'll need to do `SHAKE128(ss2)`.


The output of the two component KEMs is to be combined as follows:

~~~
ss = SHAKE128( ss1 || ss2 , 256)
~~~

where SHAKE128(M, 256) describes the use of the SHAKE128 as specified in [SHA3] with a 256 bit output.

EDNOTE: I am assuming that both kyber512 and ECDH-P256 produce 256 bit shared secrets; if not then the size of the output of SHAKE128 should be the minimum of the two.



# Mike up to here


## id-alg-composite-kem {#sec-generic-composite}

  The id-alg-composite-kem object identifier is used for identifying a
   generic composite KEM algorithm. This allows arbitrary combinations 
   of component key transport, key agreement and KEM algorithms without 
   needing the combination to be pre-registered or standardized. 

~~~
id-alg-composite-kem OBJECT IDENTIFIER ::= {
  joint-iso-itu-t(2) country(16) us(840) organization(1) 
  entrust(114027) Algorithm(80) Composite(4) KEM (5) }
~~~    

EDNOTE: this is a temporary OID for the purposes of prototyping.  We
   are requesting IANA to assign a permanent OID, see Section 6.

   Which yields an information object:


TODO - LAMPS needs to define a KEM-ALGORITHM  -  extension to RFC 5912 - Bring to IETF. We just made up the prefix "kema" (for "KEM algorithm") is that the right prefix?   

~~~
kema-CompositeKEM KEM-ALGORITHM ::= {
    IDENTIFIER id-alg-composite-kem
    VALUE CompositeCiphertextValue
    PARAMS composite-kem-params  
    PUBLIC-KEYS { pk-Composite }
    SMIME-CAPS { IDENTIFIED BY id-alg-composite } }
}
~~~

For Composite KEM, we define a composite KEM Algorithm ID as:

The following algorithm parameters MUST be included:

~~~
composite-kem-params  ::= {
    combiner     AlgorithmIdentifier
}
~~~

EDNOTE: this ASN.1 could be simplified to `composite-kem-params ::= AlgorithmIdentifier` to save a couple bytes on the wire, but we're presenting it this way for now for readability.

EDNOTE: does the (generic) params need to also carry a list of AlgorithmIdentifiers that were used in the encryption? With signatures we need this to prevent the verifier from coming up with false validity by using the wrong verification algorithm(s). With encryption I think it's less important because either your private key works or it doesn't, no harm done by trying to decrypt with the wrong alg.

If no, or a NULL, combiner is specified, then {#sect-null-combiner} applies.

See Ednote below for a discussion on some possible combiner modes   



## Other Explicit Algorithms

This variant provides a rigid way of specifying supported combinations of algorithms.

The motivation for this variant is to make it easier to reference and enforce specific combinations of algorithms. The authors envision this being useful for client-server negotiated protocols, protocol designers who wish to place constraints on allowable algorithm combinations in the protocol specification, as well as audited environments that wish to prove that only certain combinations will be supported by clients.


Explicit algorithms must define a new signature algorithm which consists of:

- A new algorithm identifier OID for the explicit algorithm.
- The algorithm identifier OID and PUBLIC-KEY type of each component algorithm.
- Algorithm parameters either declared ABSENT, or defined with a type and encoding.

<!-- See {{appdx-creatingExplicitCombinations}} for guidance on creating and registering OIDs for specific explicit combinations. -->

TODO: lay out the details.

# Combiner Algorithm Identifiers {#sect-combiners}

This section defines concrete shared secret combiners that may be used with composite KEM.

~~~ BEGIN EDNOTE ~~~

EDNOTE: We need to add a KDF-based combiner here.
Suggestions are:


Option 0)

`SS = SS1 || SS2 || .. || SSn`
with fixed length KEM algs.


Option 1) 

`SS = KDF( SS1 || SS2 || .. || SSn )`
with fixed length KEM algs.


Option 1b)

`SS = KDF( pad(SS1, len_kdf) || pad(SS2, len_kdf) )`


Option 2)

`SS = KDF( KDF(SS1) || KDF(SS2) || .. || KDF(SSn) )`


Option 2b)

`SS = KDF(SS1) XOR KDF(SS2) XOR .. XOR KDF(SSn)`


Option 3)

The combiner suggested in [Aviram2022].



At present we are opting for Option 2.

QUESTION: Should the choice of combiner be assigned an OID and made agile? If not, then we perhaps we need a version field within the composite kem structure to allow for future agility.
Answer: for -00 of this document we have decided YES, but we can revisit this.


~~~ END EDNOTE ~~~

TODO: add a section for `SS = KDF(SS1 || .. || SSn)` for people who need strict compliance with NIST SP 800-56Cr2.

## NULL {#sect-null-combiner}

If no, or NULL, parameters are supplied, then the default combiner mode SHOULD be simple concatenation.

~~~
SS =  SS1 || SS2 || .. || SSn
~~~


This mode is often appropriate, and complies with NIST SP-56Cr2, when the protocol making use of this composite KEM will use the shared secret output to derive a cryptographic key via a KDF, making it uncessessary to use a combiner within composite KEM. 

Security consideration: protocols that allow the NULL combiner MUST ensure either that none of the component shared secrets are directly controllable by an attacker (which allows for attacks similar to those discussed in {{sec-apop-attack}}), or that appropriate mitigations have been put into place.


## id-composite-kdf-combiner

This section defines a KDF-based shared secret combiner.

~~~
id-composite-kdf-combiner OBJECT IDENTIFIER ::= { TBD }
~~~

It MUST carry parameters

~~~
alg-composite-kdf-combiner-params ::= {
        kdf     AlgorithmIdentifier
}
~~~

to specify the KDF to be used.

EDNOTE: this ASN.1 could be simplified to `alg-composite-kdf-combiner-params ::=  AlgorithmIdentifier` to save a couple bytes on the wire, but we're presenting it this way for now for readability.

The behaviour of this combiner is: `SS = KDF( KDF(SS1) || KDF(SS2) || .. || KDF(SSn) )` where `||` denotes contatenation.

Formally:

~~~
Input:
   SS1, SS2, .., SSn   Shared secrets to combine

Output:
   SS                  Combined shared secret.

1.  SS = KDF( KDF(SS1) || KDF(SS2) || .. || KDF(SSn) )
~~~

The intent of this combiner is to frustrate known cryptanalytic attacks by normalizing the component shared secrets to a common fixed length (dictated by the output length of the supplied KDF), as well as attacks that exploit known weaknesses in the underlying hash function since, short of a full pre-image attack, an attacker who is able to control SSi will still not be able to control KDF(SSi).

EDNOTE: this combiner needs cryptographic review.

EDNOTE: Do we need domain separation in case other protocols use the same shared secrets in the same construction? Something like `KDF( ASCII("compositeKEM") || KDF(SS1) || KDF(SS2) || .. || KDF(SSn) )` ?


## id-blockcipher-combiner


TODO -- finish this section.

https://eprint.iacr.org/2018/024.pdf


~~~
K = F (pi_kn * ... pi_k1(0), c1 || ... || cn)
~~~
where * denotes function composition, and pi_kn denotes a blockcipher with key kn.

which would work out to (in our notation)

~~~
SS = HASH( WRAP(SSn, WRAP(SSn-1, .. WRAP(SS1, 0) .. ) || CT1 || .. || CTn)
~~~

where (SSi, Ci) are the Shared Secret and Ciphertext of component algorithm i. WRAP(key, message) would be some form of AES.

Parameters for this would need to be:

~~~
blockcipher-combiner-params ::= {
  hash    AlgorithIdentifier,
  wrap    AlgorithmIdentifier
}
~~~


# Composite Encapsulation process {#sec-encaps-proc}

Composite key encapsulations takes a CompositePublicKey as its input.  The
CompositePublicKey MUST contain composite keys (Pi .. Pn) which represent 
an algorithm which is a KEM (Key Encapsulation Method), or an algorithm that 
contains encryption or decryption primitive.  For example (RSA).   

This operation outputs a shared-secret and cipher text.

COMBINER is a function used to combine multiple shared secrets as defined in {{sect-combiners}}.

This process employs the transformations from KeyTransport or keyAgreement to KEM as described in {{sec-kems}}.

~~~
Input:  
   PK1, PK2 .. PKn   Encryption public keys. See note below on 
                     composite inputs.

   A1, A2, ... An     Component keyTransport, keyAgreement, or
                      KEM algorithms. See note below on composite 
                      inputs.

   COMBINER          A combiner function.

   SIZE              The length of shared secret to generate
                    when transforming a keyTransport into a KEM.

Output:  SS, CT

1.  for i := 1 to n
       if Ai is of type KEM:
          SSi, CTi := encaps(PKi)
       
       else, if Ai is of type keyTransport:
         SSi := random_bits(SIZE)
         CTi := encrypt(SSi, PKi)

       else, if Ai is of type keyAgreement:
          PKe, SKe := keyGen()
          SSi := keyAgree(PKi, SKe)
          CTi := PKe


  2.  SS = COMBINER(SS1, SS2, .., SSn)
      CT = CT1, CT2, .., CTn
~~~

Note on composite inputs: the method of providing the list of component keys and algorithms is flexible and beyond the scope of this pseudo-code, for example they may be carried in CompositePublicKey structure. It is also possible to perform a composite KEM that combines ciphertexts for distinct recipient keys stored, for example, in separate X.509 certificates. Variations in the process to accommodate particular private key storage mechanisms, for example when distinct keys stored in separate software or hardware keystores, are considered to be conformant to this document so long as it produces the same output as the process sketched above.

Since recursive composite public keys are disallowed in {{I-D.ounsworth-pq-composite-keys}}, no component ciphertext may itself be composite; ie the encopsulation process MUST fail if any of the public keys P1, P2, .., Pn or algorithm identifiers A1, A2, .., An are composite with the OID id-alg-composite.

# Composite Key Decapsulation {#sec-decaps-proc}

Composite key decapsulations takes a CompositePrivateKey as its input and the
sequence of Cipher texts (ct1 .. ctn) computed by the composite key 
encapsulation method.  The CompositePrivateKey MUST contain composite keys 
(Pi .. Pn) which represent an algorithm which is a KEM (Key Encapsulation Method),
or an algorithm that contains encryption or decryption primitive.  These keys 
MUST consist of the same component keys in the same order as the Composite Key 
Encapsulation process that generated them.  

This operation outputs a shared-secret.

COMBINER is a function used to combine multiple shared secrets as defined in {{sect-combiners}}.

This process employs the transformations from KeyTransport or keyAgreement to KEM as described in {{sec-kems}}.


~~~
Input:   CompositePrivateKey = SK1, SK2 .. SKn

   SK1, SK2 .. SKn    Decryption private keys. See note below on 
                      composite inputs.

   A1, A2, ... An     Component keyTransport, keyAgreement, or
                      KEM algorithms. See note below on composite 
                      inputs.

   CT1, CT2, .., CTn  Ciphertexts. see note below on composite inputs.
   
   COMBINER          A combiner function.


Output:  SS

1. for i := 1 to n
 
      if Ai is of type KEM:
          SSi := decaps(Cti, SKi)

      else, if Ai is of type keyEncipherment:
          SSi := decrypt(Cti, SKi)

       else, if Ai is of type keyAgreement:
          PKe := decode(CTi)
          SSi := keyAgree(PKe, SKi)

2. Output SS = COMBINER(SS1, SS2, .., SSn)
~~~

Note on composite inputs: the method of providing the list of component keys and algorithms is flexible and beyond the scope of this pseudo-code, for example they may be carried in CompositePublicKey structure. It is also possible to perform a composite KEM that combines ciphertexts for distinct recipient keys stored, for example, in separate X.509 certificates. Variations in the process to accommodate particular private key storage mechanisms, for example when distinct keys stored in separate software or hardware keystores, are considered to be conformant to this document so long as it produces the same output as the process sketched above.


# In Practice {#sec-in-pract}

This section addresses practical issues of how this draft affects other protocols and standards.


EDNOTE 10: Possible topics to address:

  - The size of these certs and cert chains.
  - In particular, implications for (large) composite keys / signatures / certs on the handshake stages of TLS and IKEv2.
  - If a cert in the chain is a composite cert then does the whole chain need to be of composite Certs?
  - We could also explain that the root CA cert does not have to be of the same algorithms. The root cert SHOULD NOT be transferred in the authentication exchange to save transport overhead and thus it can be different than the intermediate and leaf certs.
  - We could talk about overhead (size and processing).
  - We could also discuss backwards compatibility.
  - We could include a subsection about implementation considerations.



## Backwards Compatibility {#sec-backwards-compat}

As noted in the introduction, the post-quantum cryptographic migration will face challenges in both ensuring cryptographic strength against adversaries of unknown capabilities, as well as providing ease of migration. The composite mechanisms defined in this document primarily address cryptographic strength, however this section contains notes on how backwards compatibility may be obtained.

The term "ease of migration" is used here to mean that existing systems can be gracefully transitioned to the new technology without requiring large service disruptions or expensive upgrades. The term "backwards compatibility" is used here to mean something more specific; that existing systems as they are deployed today can interoperate with the upgraded systems of the future.

These migration and interoperability concerns need to be thought about in the context of various types of protocols that make use of X.509 and PKIX with relation to key establishment and content encryption, from online negotiated protocols such as TLS 1.3 [RFC8446] and IKEv2 [RFC7296], to non-negotiated asynchronous protocols such as S/MIME signed email [RFC8551], as well as myriad other standardized and proprietary protocols and applications that leverage CMS [RFC5652] encrypted structures.

### K-of-N modes

~~~ BEGIN EDNOTE ~~~
In the context of encryption, K-of-N modes could mean one of two things:

Type 1: sender uses a subset

This would mean the sender (encrypter) uses a subset of K the N component keys within the receiver's public key. The obvious way to combine them is with the {{sec-encaps-proc}} but skipping the unused keys / algorithms and emitting a NULL ciphertext in their place. This mechanism is straight-forward and allows ease of migration where a sender encounters a composite encryption public key where it does not support all component algorithms. It also supports performance optimization where, for example, a receiver can be issued a key with many component keys and a sender can choose the highest-performance subset that are still considered safe.


Type 2: receiver uses a subset

This would mean that the sender (encrypter) uses all N of the component keys within the receiver's public key in such a way that the receiver (decrypter) only needs to use K private keys to decrypt the message. This implies the need for some kind of Shamir's-like secret splitting scheme. This is a reasonably complex mechanism and it's currently unclear if there are any use-cases that require such a mechanism.

~~~ END EDNOTE ~~~


### Parallel PKIs

We present the term "Parallel PKI" to refer to the setup where a PKI end entity possesses two or more distinct public keys or certificates for the same identity (name), but containing keys for different cryptographic algorithms. One could imagine a set of parallel PKIs where an existing PKI using legacy algorithms (RSA, ECC) is left operational during the post-quantum migration but is shadowed by one or more parallel PKIs using pure post quantum algorithms or composite algorithms (legacy and post-quantum).

Equipped with a set of parallel public keys in this way, a client would have the flexibility to choose which public key(s) or certificate(s) to use in a given signature operation. 

For negotiated protocols, the client could choose which public key(s) or certificate(s) to use based on the negotiated algorithms.

For non-negotiated protocols, the details for obtaining backwards compatibility will vary by protocol, but for example in CMS [RFC5652].

EDNOTE: I copied and pruned this text from {{I-D.ounsworth-pq-composite-sigs}}. It probably needs to be fleshed out more as we better understand the implementation concerns around composite encryption.

<!-- End of In Practice section -->

# IANA Considerations {#sec-iana}
The ASN.1 module OID is TBD.  


<!-- End of IANA Considerations section -->


# Security Considerations


## Policy for Deprecated and Acceptable Algorithms

Traditionally, a public key, certificate, or signature contains a single cryptographic algorithm. If and when an algorithm becomes deprecated (for example, RSA-512, or SHA1), it is obvious that structures using that algorithm are implicitly revoked.

In the composite model this is less obvious since implementers may decide that certain cryptographic algorithms have complementary security properties and are acceptable in combination even though one or both algorithms are deprecated for individual use. As such, a single composite public key, certificate, signature, or ciphertext may contain a mixture of deprecated and non-deprecated algorithms. 

Specifying behaviour in these cases is beyond the scope of this document, but should be considered by Implementers and potentially in additional standards.

EDNOTE: Max is working on a CRL mechanism to accomplish this.

## OR Modes

TODO -- we'll need security consideration analysis of whatever OR modes we choose.


## Cryptographic review of combiner

EDNOTE: LAMPS should probably request CFRG review of this draft to ensure that the combiner is resistant to all known cryptographic attacks.

### Need for a KDF within the combiner

It is expected that the majority of uses of the KEM defined in this document will be within a construct such as {{I-D.perret-prat-lamps-cms-pq-kem}} which supplies the KEM output to a KDF in order to derive a wrapping key. In these cases it is redundant for the combiner within the composite KEM to also use a KDF. However, it is possible for protocol designers to want to use a KEM output -- or a truncation of it -- directly as a symmetric key; for this purpose we have included a KDF in the composite KEM construction.

In protocols where the KEM output will be supplied to a KDF, it should be safe to use a NULL KDF within the composite KEM -- ie the KDF where `KDF(m) = m` -- but we leave the details of any such security analysis to the protocol designers who wish to implement it.

### APOP Attack on concatenated keys {#sec-apop-attack}

See the attack analysis described in summary in [Aviram2021].

The pre-conditions for the described attack are quite strong: namely that the attacker has full control of both the content and length of the first shared secret in the combiner, and that the attacker can perform collision attacks against the underlying KDF.

We believe that, in general, neither of these pre-conditions are met within PKIX protocols. First, any key transport, key agreement, or KEM primitive approved for use within PKIX sets a fixed length for the shared secret that it produces so that the attacker cannot change the shared secret length between subsequent runs of the same protocol. This justification aligns with the justification used for {{I-D.ietf-tls-hybrid-design}}. Second, any non-deprecated KDF will not allow collision attacks.

In addition, the combiner construction defined in this document aims to provide additional collision resistance on top of that provided by the underlying KDF.



### Aviram2022

See the attack analysis described in summary in [Aviram2022].


This paper is largely critiquing the use of HKDF (HMAC) as a dual-PRF combiner for two secrets. This is not exactly what we are doing here.

[Aviram2022] gives the following definition:
"If we would like to combine two keys, either of which might be influenced by an attacker, we need a dual-PRF as the keycombiner: That is, a function which is a PRF when keyed by either input.

We believe the construction offered in this document meets this definition of a dual-PRF so long as the chosen KDF is itself a PRF. This holds even if the chosen KDF is HKDF with the same key (salt) used in each KDF() operation.

<!-- End of Security Considerations section -->

--- back

# Examples {#appdx-examples}

TBD

# ASN.1 Module

TBD -- UPDATE

~~~ ASN.1

<CODE STARTS>

Composite-Keys-2022
  { TBD }

DEFINITIONS IMPLICIT TAGS ::= BEGIN

EXPORTS ALL;

IMPORTS
-- any?

--
-- Object Identifiers
--

-- To be replaced by IANA
id-alg-composite-kem OBJECT IDENTIFIER ::= {
joint-iso-itu-t(2) country(16) us(840) organization(1) 
entrust(114027) Algorithm(80) Composite(4) KEM (5) }

id-composite-kdf-combiner OBJECT IDENTIFIER ::= { TBD }


--
-- Composite structures
--

CompositeCiphertextValue ::= SEQUENCE SIZE (2..MAX) OF BIT STRING

kema-CompositeKEM KEM-ALGORITHM ::= {
    IDENTIFIER id-alg-composite-kem
    VALUE CompositeCiphertextValue
    PARAMS composite-kem-params  
    PUBLIC-KEYS { pk-Composite }
    SMIME-CAPS { IDENTIFIED BY id-alg-composite } }
}

TODO: this assumes that KEM-ALGORITHM is defined, which it currently is not.

composite-kem-params  ::= {
    combiner     AlgorithmIdentifier
}

alg-composite-kdf-combiner-params ::= {
        kdf     AlgorithmIdentifier
}

END

<CODE ENDS>

~~~


# Intellectual Property Considerations

The following IPR Disclosure relates to this draft:

https://datatracker.ietf.org/ipr/3588/

EDNOTE:   I don't think this applies to this draft.



# Contributors and Acknowledgements
This document incorporates contributions and comments from a large group of experts. The Editors would especially like to acknowledge the expertise and tireless dedication of the following people, who attended many long meetings and generated millions of bytes of electronic mail and VOIP traffic over the past year in pursuit of this document:

Serge Mister (Entrust), Ali Noman (Entrust), Scott Fluhrer (Cisco), Jan Klaußner (D-Trust), Max Pala (CableLabs), and
Douglas Stebila (University of Waterloo).

We are grateful to all, including any contributors who may have
been inadvertently omitted from this list.

This document borrows text from similar documents, including those referenced below. Thanks go to the authors of those
   documents.  "Copying always makes things easier and less error prone" - [RFC8411].

## Making contributions

Additional contributions to this draft are welcome. Please see the working copy of this draft at, as well as open issues at:

https://github.com/EntrustCorporation/draft-composite-kem/


<!-- End of Contributors section -->
