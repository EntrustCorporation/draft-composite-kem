---
title: Composite KEM For Use In Internet PKI
abbrev: PQ Composite Keys
# <!-- EDNOTE: Edits the draft name -->
docname: draft-ounsworth-pq-composite-kem-00
# <!-- date: 2012-01-13 -->
# <!-- date: 2012-01 -->
# <!-- date: 2012 -->

# <!-- stand_alone: true -->
ipr: trust200902
area: Security
wg: LAMPS
kw: Internet-Draft
cat: std

coding: us-ascii
pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:
    -
      ins: M. Ounsworth
      name: Mike Ounsworth
      org: Entrust Limited
      abbrev: Entrust
      street: 2500 Solandt Road â€“ Suite 100
      city: Ottawa, Ontario
      country: Canada
      code: K2K 3G5
      email: mike.ounsworth@entrust.com

    -
      ins: J. Gray
      name: John Gray
      org: Entrust Limited
      abbrev: Entrust
      email: john.gray@entrust.com

normative:
  RFC1421:
  RFC2119:
  RFC2986:
  RFC4210:
  RFC5280:
  RFC5652:
  RFC5912:
  RFC5914:
  RFC5958:
  RFC7468:
  RFC8174:
  RFC8411:
  X.690:
      title: "Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)"
      date: November 2015
      author:
        org: ITU-T
      seriesinfo:
        ISO/IEC: 8825-1:2015
  I-D.draft-ounsworth-pq-composite-keys-01:
  I-D.draft-perret-prat-lamps-cms-pq-kem-00:


# <!-- EDNOTE: full syntax for this defined here: https://github.com/cabo/kramdown-rfc2629 -->

informative:
  RFC3279:
  RFC5990:
  I-D.draft-ietf-tls-hybrid-design-04:
  Bindel2017:
    title: "Transitioning to a quantum-resistant public key infrastructure"
    target: "https://link.springer.com/chapter/10.1007/978-3-319-59879-6_22"
    author:
      -
        ins: N. Bindel
        name: Nina Bindel
      -
        ins: U. Herath
        name: Udyani Herath
      -
        ins: M. McKague
        name: Matthew McKague
      -
        ins: D. Stebila
        name: Douglas Stebila
    date: 2017
  Aviram2022:
    title: "Practical (Post-Quantum) Key Combiners from One-Wayness and Applications to TLS."
    target: "https://eprint.iacr.org/2022/065"
    author:
      -
        ins: 
  Aviram2021:
    title: "Concatenating Secrets May Be Dangerous"
    target: "https://github.com/nimia/kdf_public"
    Author:
      -
        ins: N. Aviram
        name: Nimrod Aviram
      - 
        ins: B. Dowling
        name: Benjamin Dowling
      - 
        ins: Komargodski
        name: Ilan Komargodski
      - 
        ins: Paterson
        name: Kenneth G Paterson
      - 
        ins: Ronen
        name: Eyal Ronen
      -
        ins: Yogev
        name: Eylon Yogev
    date: 2022




--- abstract

The migration to post-quantum cryptography is unique in the history of modern digital cryptography in that neither the old outgoing nor the new incoming algorithms are fully trusted to protect data for the required data lifetimes. The outgoing algorithms, such as RSA and elliptic curve, may fall to quantum cryptalanysis, while the incoming post-quantum algorithms face uncertainty about both the underlying mathematics as well as hardware and software implementations that have not had sufficient maturing time to rule out classical cryptanalytic attacks and implementation bugs.

Cautious implementors may wish to layer cryptographic algorithms such that an attacker would need to break all of them in order to compromise the data being protected. For digital signatures, this is referred to as "dual", and for encryption key establishment this as reffered to as "hybrid". This document, and its companions, defines a specific instantiation of the dual and hybrid paradigm called "composite" where multiple cryptographic algorithms are combined to form a single key, signature, or key encapsulation mechanism (KEM) such that they can be treated as a single atomic object at the protocol level.

EDNOTE: the terms "dual" and "hybrid" are currently in flux. We anticipate an Informational draft to normalize terminology, and will update this draft accordingly.

This document defines a Composite key encapsulation mechanism (KEM)
procedure, for use with Composite keys which consist of combinations 
of Encryption or KEM algorithms for each composite component  
algorithm.  

This document is intended to be coupled with the composite keys
structure define in [draft-ounsworth-pq-composite-keys-01] and the CMS KEM-TRANS mechanism in [draft-perret-prat-lamps-cms-pq-kem-00].

<!-- End of Abstract -->


--- middle

# Introduction {#sec-intro}

During the transition to post-quantum cryptography, there will be uncertainty as to the strength of cryptographic algorithms; we will no longer fully trust traditional cryptography such as RSA, Diffie-Hellman, DSA and their elliptic curve variants, while me may also not fully trust their post-quantum replacements until they have had sufficient scrutiny and time to discover and fix implementation bugs. Unlike previous cryptographic algorithm migrations, the choice of when to migrate and which algorithms to migrate to, is not so clear. Even after the migration period, it may be advantageous for an entity's cryptographic identity to be composed of multiple public-key algorithms.

The deployment of composite public keys, and composite signatures and composite encryption using post-quantum algorithms will face two challenges


- Algorithm strength uncertainty: During the transition period, some post-quantum signature and encryption algorithms will not be fully trusted, while also the trust in legacy public key algorithms will start to erode.  A relying party may learn some time after deployment that a public key algorithm has become untrustworthy, but in the interim, they may not know which algorithm an adversary has compromised.
- Migration: During the transition period, systems will require mechanisms that allow for staged migrations from fully classical to fully post-quantum-aware cryptography.


This document provides a mechanism to address algorithm strength uncertainty by building on [draft-ounsworth-pq-composite-keys-00] (NOTE: need kramdown formatting help with this ref) by providing the format and process for combining multiple cryptographic algorithms into a single key encapsulation operation. Backwards compatibility is addressed via using composite in conjunction with a non-composite hybrid mode such as that described in [draft-becker-guthrie-noncomposite-hybrid-auth-00] (NOTE: need kramdown formatting help with this ref).


This document is intended for general applicability anywhere that key establishment or enveloped content encryption is used within PKIX or CMS structures.


<!-- End of Introduction section -->


## Terminology {#sec-terminology}
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 {{RFC2119}}  {{RFC8174}} when, and only when, they appear in all capitals, as shown here.

The following terms are used in this document:

ALGORITHM:
          An information object class for identifying the type of
            cryptographic key being encapsulated.

BER:
          Basic Encoding Rules (BER) as defined in [X.690].

CLIENT:
          Any software that is making use of a key at runtime.
          This includes a signer, verifyir, encryptor, decryptor.

COMBINER MODE:
          A combiner mode specifies how keys are to be combined
          together into a single cryptographic operation. 
          Examples include AND, OR, K-of-N.
          Specifications of composite signature or encryption 
          proceedures will need to specify the behaviour under 
          each mode.            

COMPONENT ALGORITHM:
          A single basic algorithm which is contained within a
            composite algorithm.

COMPOSITE ALGORITHM:
          An algorithm which is a sequence of two or more component
            algorithms.

DER:
          Distinguished Encoding Rules as defined in [X.690].

KEM:
        A key encapsulation mechanism as defined in {{sec-kems}}.
        
POST-QUANTUM AGLORITHM:
          Any cryptographic algorithm which is believed to be resistant
          to classical and quantum cryptanalysis, such as the algorithms being considered for standardization by NIST.

PUBLIC / PRIVATE KEY:
          The public and private portion of an asymmetric cryptographic
            key, making no assumptions about which algorithm.

SHARED SECRET:
        A value established between two communicating parties by means of a
        cryptographic operation, but which cannot be learned by an active or 
        passive adversary.

# Composite KEM Structures

## Key Encapsulation Mechanisms (KEMs) {#sec-kems}

We borrow here the definition of a key encapsulation mecanism (KEM) from [I-D.draft-ietf-tls-hybrid-design], in which a KEM consists of three algorithms:

   *  KeyGen() -> (pk, sk): A probabilistic key generation algorithm,
      which generates a public key pk and a secret key sk.

   *  Encaps(pk) -> (ct, ss): A probabilistic encapsulation algorithm,
      which takes as input a public key pk and outputs a ciphertext ct
      and shared secret ss.

   *  Decaps(sk, ct) -> ss: A decapsulation algorithm, which takes as
      input a secret key sk and ciphertext ct and outputs a shared
      secret ss, or in some cases a distinguished error value.


This document is not concerned with the KeyGen() algorithm of a KEM, but it is included for completeness.

The KEM interface defined above differs from both tradational key transport mechanism (for example for use with KeyTransRecipientInfo defined in [RFC5652]), and key agreement (for example for use with KeyAgreeRecipientInfo defined in [RFC5652]). 

The KEM interface was chosen as the interface for a composite key exchange because both key transport and key agreement mechanisms can be promoted into KEMs in the following ways:

A key transport mechanism can be promoted into a KEM.Encaps(pk) by generating a random shared secret ss and performing KeyTrans.Encrypt(pk, ss) -P ct; and into a KEM.Decaps(sk, ct) by KeyTrans.Decrypt(sk, ct) -> ss. This follows the pattern of RSA-KEM [RFC5990].

A key agreement mechanism can be promoted into a KEM.Encaps(pk) by generating an ephemeral key pair (pk_e, sk_e), and performing KeyAgree(pk, sk_e) -> (ss, pk_e); and into a KEM.Decaps(sk, ct) by completing the key agreement as KeyAgree(pk_e, sk) -> ss.

A composite KEM allows two or more underlying key transport, key agreement, or KEM alogrithms to be combined into a single cryptographic operations by performing each operation, promoted to a KEM as outline above, and concatenating all component shared secrets into a single shared secret.



The main security property for KEMs is indistinguishability under
adaptive chosen ciphertext attack (IND-CCA2), which means that shared
secret values should be indistinguishable from random strings even
given the ability to have other arbitrary ciphertexts decapsulated.

A weaker security notion is indistinguishability under chosen
plaintext attack (IND-CPA), which means that the shared secret values
should be indistinguishable from random strings given a copy of the
public key.  IND-CPA roughly corresponds to security against a
passive attacker, and sometimes corresponds to one-time key exchange.


The composite KEM mechanisms meets these security properties if and only if the component primitives meet them.

TODO: needs more formal analysis that the methods of promoting KeyTrans and KeyAgree meet this.

TODO: QUESTION: If we return `SS = SS1 || .. || SSn`, does that make this mechanism fail IND-CCA2? Do we need to carry a KDF here too and do `SS = KDF(SS1 || .. || SSn)`? Also take another look at {{sec-apop-attack}} with regards to this question.


## Composite Keys

TODO

### Key Usage Bits

TODO


## kem-CompositeKEM

TODO


## CompositeCiphertextValue

TODO

~~~
CompositeCihpertextValue ::= SEQUENCE SIZE (2..MAX) OF BIT STRING
~~~

## Encoding Rules

Many protocol specifications will require that composite KEM data structures be represented by an octet string or bit string.

When an octet string is required, the DER encoding of the composite data structure SHALL be used directly.

EDNOTE: will this definition include an ASN.1 tag and length byte inside the OCTET STRING object? If so, that's probably an extra uneccessary layer.

When a bit string is required, the octets of the DER encoded composite data structure SHALL be used as the bits of the bit string, with the most significant bit of the first octet becoming the first bit, and so on, ending with the least significant bit of the last octet becoming the last bit of the bit string.

In the interests of simplicity and avoiding compatibility issues, implementations that parse these structures MAY accept both BER and DER.

# Algorithm Identifiers

TODO

## id-alg-composite

TODO


## Other Explicit Algorithms

TODO

# Composite Key Encapsulation

Composite key encapsulations takes a CompositePublicKey as its input.  The
CompositePublicKey MUST contain composite keys (Pi .. Pn) which represent 
an algorithm which is a KEM (Key Encapsulation Method), or an algorithm that 
contains encryption or decryption primitive.  For example (RSA).   

This operation outputs a shared-secret and cipher text.

~~~
Input:  CompositePublicKey (PK1, PK2 .. PKn)

Output:  SS, CT

1.  for i := 1 to n
       if PKi is of type KEM:
          SSi, CTi := encaps(PKi)
       
       else, if PKi is of type keyEncipherment:
         SSi := random_bits(SIZE)
         CTi := encrypt(SSi, PKi)

       else, if PKi is of type keyAgreement:
          PKe, SKe := keyGen()
          SSi := keyAgree(PKi, SKe)
          CTi := PKe


  2.  SS = SSi ||  SSn
      CT = CT1, CT2, .., CTn
~~~


# Composite Key Decapsulation

Composite key decapsulations takes a CompositePrivateKey as its input and the
sequence of Cipher texts (ct1 .. ctn) computed by the composite key 
encapsulation method.  The CompositePrivateKey MUST contain composite keys 
(Pi .. Pn) which represent an algorithm which is a KEM (Key Encapsulation Method),
or an algorithm that contains encryption or decryption primitive.  These keys 
MUST consist of the same component keys in the same order as the Composite Key 
Encapsulation process that generated them.  

This operation outputs a shared-secret.


~~~
Input:   CompositePrivateKey = SK1, SK2 .. SKn
          CT = CT1, CT2, .., CTn

Output:  SS

1. for i := 1 to n
 
      if SKi is of type KEM:
          SSi := decaps(Cti, SKi)

      else, if SKi is of type keyEncipherment:
          SSi := decrypt(Cti, SKi)

       else, if PKi is of type keyAgreement:
          PKe := decode(CTi)
          SSi := keyAgree(PKe, SKi)

2. Output SS = SSi ||  SSn
~~~


~~~ BEGIN EDNOTE ~~~
EDNOTE: We need to add a KDF-based combiner here.
Suggestions are:


Option 0)

SS = SS1 || SS2 || .. || SSn
with fixed length KEM algs.



Option 1) 

SS = KDF( SS1 || SS2 || .. || SSn )
with fixed length KEM algs.



Option 1b)

SS = KDF( pad(SS1, len_kdf) || pad(SS2, len_kdf) )



Option 2)

SS = KDF( KDF(SS1) || KDF(SS2) || .. || KDF(SSn) )


Option 2b)

SS = KDF(SS1) XOR KDF(SS2) XOR .. XOR KDF(SSn)


Option 3)

The combiner suggested in [Aviram2022].



At present we are opting for Option 2.

QUESTION: Should the choice of combiner be assigned an OID and made agile? If not, then we perhaps we need a version field within the composite kem structure to allow for future agility.


~~~ END EDNOTE ~~~

## Composite KEM CipherText Encoding

For ease of use when encoding and decoding, the following encoding is 
suggested for the CipherText.   

CompositeKemCT :: SEQUENCE SIZE (2..MAX) of OctetString

This will allow implementations a simple and uniform way to distribute
the set of Cipher texts required for the decapsulation process.  
It is not mandatory as an implementation could choose to store the
set of Cipher texts produced in a different format, so long as they
are available at time of decapsulation.



## Generic vs Explicit Variants

TBD if we need to say anything, or if it's all covered already by the keys draft.



# In Practice {#sec-in-pract}

This section addresses practical issues of how this draft affects other protocols and standards.


EDNOTE 10: Possible topics to address:

  - The size of these certs and cert chains.
  - In particular, implications for (large) composite keys / signatures / certs on the handshake stages of TLS and IKEv2.
  - If a cert in the chain is a composite cert then does the whole chain need to be of composite Certs?
  - We could also explain that the root CA cert does not have to be of the same algorithms. The root cert SHOULD NOT be transferred in the authentication exchange to save transport overhead and thus it can be different than the intermediate and leaf certs.
  - We could talk about overhead (size and processing).
  - We could also discuss backwards compatibility.
  - We could include a subsection about implementation considerations.


<!-- End of In Practice section -->

# IANA Considerations {#sec-iana}
The ASN.1 module OID is TBD.  


<!-- End of IANA Considerations section -->


# Security Considerations


## Policy for Deprecated and Acceptable Algorithms

Traditionally, a public key, certificate, or signature contains a single cryptographic algorithm. If and when an algorithm becomes deprecated (for example, RSA-512, or SHA1), it is obvious that structures using that algorithm are implicitly revoked.

In the composite model this is less obvious since implementers may decide that certain cryptographic algorithms have complementary security properties and are acceptable in combination even though one or both algorithms are deprecated for individual use. As such, a single composite public key, certificate, signature, or ciphertext may contain a mixture of deprecated and non-deprecated algorithms. 

Specifying behaviour in these cases is beyond the scope of this document, but should be considered by implementors and potentially in addiniotal standards.

EDNOTE: Max is working on a CRL mechanism to accomplish this.

## OR Modes

TODO

## Cryptographic review of combiner

EDNOTE: LAMPS should probably request CFRF review of this draft to ensure that the combiner is resistant to all known cryptograhpic attacks.

### APOP Attack on concatenated keys {#sec-apop-attack}

See the attack analysis described in summary in [Aviram2021].

The pre-conditions for the described attack are quite strong: namely that the attacker has full control of both the content and length of the first shared secret in the combiner, and that the attacker can perform collision attacks against the underlying KDF.

We believe that, in general, neither of these pre-conditions are met within PKIX protocols. First, any key transport, key agreement, or KEM primitive approved for use within PKIX sets a fixed length for the shared secret that it produces so that the attacker cannot change the shared secret length between subsequent runs of the same protocol. This justification aligns with the justification used for [I-D.draft-ietf-tls-hybrid-design]. Second, any non-depricated KDF will not allow collision attacks.

In addition, the combiner construction defined in this document aims to provide additional collision resistance on top of that provided by the underlying KDF.



### Aviram2022

See the attack analysis described in summary in [Aviram2022].


This paper is largely critiquing the use of HKDF (HMAC) as a dual-PRF combiner for two secrets. This is not exactly what we are doing here.

[Aviram2022] gives the following definition:
"If we would like to combine two keys, either of which might be influenced by an attacker, we need adual-PRF as the keycombiner: That is, a function which is a PRF when keyed by either input.

We believe the construction offered in this document meets this definition of a dual-PRF so long as the chosen KDF satisfies the requirement of being a one-way function. This holds even if the chosen KDF is HKDF with the same key (salt) used in each KDF() operation.

<!-- End of Security Considerations section -->

--- back

# Examples {#appdx-examples}

TBD

# ASN.1 Module

TBD -- UPDATE

~~~ ASN.1

<CODE STARTS>

Composite-Keys-2022
  { TBD }

DEFINITIONS IMPLICIT TAGS ::= BEGIN

EXPORTS ALL;

IMPORTS
  PUBLIC-KEY, SIGNATURE-ALGORITHM
    FROM AlgorithmInformation-2009  -- RFC 5912 [X509ASN1]
      { iso(1) identified-organization(3) dod(6) internet(1)
        security(5) mechanisms(5) pkix(7) id-mod(0)
        id-mod-algorithmInformation-02(58) }

  SubjectPublicKeyInfo
    FROM PKIX1Explicit-2009
      { iso(1) identified-organization(3) dod(6) internet(1)
        security(5) mechanisms(5) pkix(7) id-mod(0)
        id-mod-pkix1-explicit-02(51) }

  OneAsymmetricKey
    FROM AsymmetricKeyPackageModuleV1
      { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
        pkcs-9(9) smime(16) modules(0)
        id-mod-asymmetricKeyPkgV1(50) } ;

--
-- Object Identifiers
--

-- To be replaced by IANA
id-composite-key OBJECT IDENTIFIER ::= {
  iso(1) identified-organization(3) dod(6) internet(1) private(4) 
  enterprise(1) OpenCA(18227) algorithms(2) id-pk-compositeCrypto(1) }

--
-- Public Key
--

pk-Composite PUBLIC-KEY ::= {
    id id-composite-key,
    KeyValue CompositePublicKey,
    Params CompositeParams ARE OPTIONAL,
    PrivateKey CompositePrivateKey,
}

CompositePublicKey ::= SEQUENCE SIZE (2..MAX) OF SubjectPublicKeyInfo

CompositePublicKeyOs ::= OCTET STRING (CONTAINING CompositePublicKey 
                                            ENCODED BY der)

CompositePublicKeyBs ::= BIT STRING (CONTAINING CompositePublicKey 
                                            ENCODED BY der)

CompositePrivateKey ::= SEQUENCE SIZE (2..MAX) OF OneAsymmetricKey


-- pk-explicitComposite - Composite public key information object

pk-explicitComposite{OBJECT IDENTIFIER:id, PUBLIC-KEY:firstPublicKey,
  FirstPublicKeyType, PUBLIC-KEY:secondPublicKey, SecondPublicKeyType} 
  PUBLIC-KEY ::= {
    IDENTIFIER id
    KEY ExplicitCompositePublicKey{firstPublicKey, FirstPublicKeyType,
      secondPublicKey, SecondPublicKeyType}
    PARAMS ARE absent
}

   The following ASN.1 object class then automatically generates the
   public key structure from the types defined in pk-explicitComposite.

-- ExplicitCompositePublicKey - The data structure for a composite 
-- public key sec-composite-pub-keys and SecondPublicKeyType are needed 
-- because PUBLIC-KEY contains a set of public key types, not a single
-- type.
-- TODO The parameters should be optional only if they are marked 
-- optional in the PUBLIC-KEY


ExplicitCompositePublicKey{PUBLIC-KEY:firstPublicKey, FirstPublicKeyType,
  PUBLIC-KEY:secondPublicKey, SecondPublicKeyType} ::= SEQUENCE {
    firstPublicKey SEQUENCE {
        params firstPublicKey.&Params OPTIONAL,
        publicKey FirstPublicKeyType
    },
    secondPublicKey SEQUENCE {
        params secondPublicKey.&Params OPTIONAL,
        publicKey SecondPublicKeyType
    }
}

END

<CODE ENDS>

~~~


# Intellectual Property Considerations

The following IPR Disclosure relates to this draft:

https://datatracker.ietf.org/ipr/3588/



# Contributors and Acknowledgements
This document incorporates contributions and comments from a large group of experts. The Editors would especially like to acknowledge the expertise and tireless dedication of the following people, who attended many long meetings and generated millions of bytes of electronic mail and VOIP traffic over the past year in pursuit of this document:

Serge Mister (Entrust),
Douglas Stebila (University of Waterloo).

We are grateful to all, including any contributors who may have
been inadvertently omitted from this list.

This document borrows text from similar documents, including those referenced below. Thanks go to the authors of those
   documents.  "Copying always makes things easier and less error prone" - [RFC8411].

## Making contributions

Additional contributions to this draft are weclome. Please see the working copy of this draft at, as well as open issues at:

https://github.com/EntrustCorporation/draft-composite-kem/


<!-- End of Contributors section -->
