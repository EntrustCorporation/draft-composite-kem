---
title: Composite KEM For Use In Internet PKI
abbrev: PQ Composite Keys
docname: draft-ounsworth-pq-composite-kem-01

# <!-- stand_alone: true -->
ipr: trust200902
area: Security
wg: LAMPS
kw: Internet-Draft
cat: std

coding: us-ascii
pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:
    -
      ins: M. Ounsworth
      name: Mike Ounsworth
      org: Entrust Limited
      abbrev: Entrust
      street: 2500 Solandt Road – Suite 100
      city: Ottawa, Ontario
      country: Canada
      code: K2K 3G5
      email: mike.ounsworth@entrust.com

    -
      ins: J. Gray
      name: John Gray
      org: Entrust Limited
      abbrev: Entrust
      email: john.gray@entrust.com

normative:
  RFC2119:
  RFC5280:
  RFC5480:
  RFC5652:
  RFC8174:
  RFC8410:
  RFC8411:
  #<!-- I-D.draft-ietf-lamps-kyber-certificates-00: -->
  I-D.draft-ounsworth-pq-composite-keys-01:
  I-D.draft-perret-prat-lamps-cms-pq-kem-00:
  SHA3:
    title: "SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions, FIPS PUB 202, DOI 10.6028/NIST.FIPS.202"
    author: 
      org: "National Institute of Standards and Technology (NIST)"
    date: August 2015
    target: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf
  X.690:
      title: "Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)"
      date: November 2015
      author:
        org: ITU-T
      seriesinfo:
        ISO/IEC: 8825-1:2015
  BSI-ECC:
    title: "Technical Guideline BSI TR-03111: Elliptic Curve Cryptography. Version 2.10"
    author:
      org: "Federal Office for Information Security (BSI)"
    date: 2018-06-01
  # SEC1:
  #   title: "Standards for Efficient Cryptography Group, SEC1: Elliptic Curve Cryptography"
  #   date: "May 2009"
  #   target: <https://www.secg.org/sec1-v2.pdf>
  SP.800-56Ar3:
    title: "Recommendation for Pair-Wise Key-Establishment Schemes Using Discrete Logarithm Cryptography"
    date: April 2018
    author: 
      org: "National Institute of Standards and Technology (NIST)"
    target: https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf



# <!-- EDNOTE: full syntax for this defined here: https://github.com/cabo/kramdown-rfc2629 -->

informative:
  RFC5639:
  RFC5990:
  RFC6090:
  RFC7296:
  RFC7748:
  RFC8446:
  RFC8551:
  I-D.draft-ounsworth-pq-composite-sigs-07:
  I-D.draft-ietf-tls-hybrid-design-04:
  I-D.draft-ounsworth-cfrg-kem-combiners-00:
  I-D.draft-driscoll-pqt-hybrid-terminology-01:
  Aviram2022:
    title: "Practical (Post-Quantum) Key Combiners from One-Wayness and Applications to TLS."
    target: "https://eprint.iacr.org/2022/065"
    author:
      -
        ins: 
  Aviram2021:
    title: "Concatenating Secrets May Be Dangerous"
    target: "https://github.com/nimia/kdf_public"
    Author:
      -
        ins: N. Aviram
        name: Nimrod Aviram
      - 
        ins: B. Dowling
        name: Benjamin Dowling
      - 
        ins: Komargodski
        name: Ilan Komargodski
      - 
        ins: Paterson
        name: Kenneth G Paterson
      - 
        ins: Ronen
        name: Eyal Ronen
      -
        ins: Yogev
        name: Eylon Yogev
    date: 2022




--- abstract

The migration to post-quantum cryptography is unique in the history of modern digital cryptography in that neither the old outgoing nor the new incoming algorithms are fully trusted to protect data for the required data lifetimes. The outgoing algorithms, such as RSA and elliptic curve, may fall to quantum cryptalanysis, while the incoming post-quantum algorithms face uncertainty about both the underlying mathematics as well as hardware and software implementations that have not had sufficient maturing time to rule out classical cryptanalytic attacks and implementation bugs.

Cautious implementers may wish to layer cryptographic algorithms such that an attacker would need to break all of them in order to compromise the data being protected using either a Post-Quantum / Traditional Hybrid, Post-Quantum / Post-Quantum Hybrid, or combinations thereof. This document, and its companions, defines a specific instantiation of hybrid paradigm called "composite" where multiple cryptographic algorithms are combined to form a single key, signature, or key encapsulation mechanism (KEM) such that they can be treated as a single atomic object at the protocol level.


This document defines the structure CompositeCiphertextValue which is a sequence of the respective ciphertexts for each component algorithm. Explicit pairings of algorithms are defined which should meet most Internet needs. The generic composite key type is also defined which allows arbitrary combinations of key types to be placed in the CompositePublicKey and CompositePrivateKey structures without needing the combination to be pre-registered or pre-agreed. For the purpose of combining KEMs, the combiner function from {{I-D.ounsworth-cfrg-kem-combiners}} is used.


This document is intended to be coupled with the composite keys
structure define in {{I-D.ounsworth-pq-composite-keys}} and the CMS KEM-TRANS mechanism in {{I-D.perret-prat-lamps-cms-pq-kem}}.


<!-- End of Abstract -->


--- middle

# Changes in version -01

* Sycronized terminology with I-D.draft-driscoll-pqt-hybrid-terminology-01.

# Introduction {#sec-intro}

During the transition to post-quantum cryptography, there will be uncertainty as to the strength of cryptographic algorithms; we will no longer fully trust traditional cryptography such as RSA, Diffie-Hellman, DSA and their elliptic curve variants, while we may also not fully trust their post-quantum replacements until they have had sufficient scrutiny and time to discover and fix implementation bugs. Unlike previous cryptographic algorithm migrations, the choice of when to migrate and which algorithms to migrate to, is not so clear. Even after the migration period, it may be advantageous for an entity's cryptographic identity to be composed of multiple public-key algorithms.

The deployment of composite public keys and composite encryption using post-quantum algorithms will face two challenges


- Algorithm strength uncertainty: During the transition period, some post-quantum signature and encryption algorithms will not be fully trusted, while also the trust in legacy public key algorithms will start to erode.  A relying party may learn some time after deployment that a public key algorithm has become untrustworthy, but in the interim, they may not know which algorithm an adversary has compromised.
- Migration: During the transition period, systems will require mechanisms that allow for staged migrations from fully classical to fully post-quantum-aware cryptography.


This document provides a mechanism to address algorithm strength uncertainty by building on {{I-D.ounsworth-pq-composite-keys}} by providing the format and process for combining multiple cryptographic algorithms into a single key encapsulation operation. Backwards compatibility is not directly covered in this document, but is the subject of {{sec-backwards-compat}}.


This document is intended for general applicability anywhere that key establishment or enveloped content encryption is used within PKIX or CMS structures.



<!-- End of Introduction section -->


## Terminology {#sec-terminology}
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 {{RFC2119}}  {{RFC8174}} when, and only when, they appear in all capitals, as shown here.

This document is consistent with all terminology from {{I-D.driscoll-pqt-hybrid-terminology}}.

In addition, the following terms are used in this document:


BER:
          Basic Encoding Rules (BER) as defined in [X.690].

CLIENT:
          Any software that is making use of a cryptographic key.
          This includes a signer, verifier, encrypter, decrypter.

COMBINER:
          A combiner specifies how multiple shared secrets
          are combined into a single shared secret.
DER:
          Distinguished Encoding Rules as defined in [X.690].

KEM:
        A key encapsulation mechanism as defined in {{sec-kems}}.

PKI:
          Public Key Infrastructure, as defined in [RFC5280].

SHARED SECRET:
        A value established between two communicating parties for use as cryptographic key material, but which cannot be learned by an active or 
        passive adversary. This document is concerned with shared secrets established via public key cryptagraphic operations.


# Composite KEM Structures

## Key Encapsulation Mechanisms (KEMs) {#sec-kems}

We borrow here the definition of a key encapsulation mechanism (KEM) from {{I-D.ietf-tls-hybrid-design}}, in which a KEM is a cryptographic primitive that consists of three algorithms:

   *  KeyGen() -> (pk, sk): A probabilistic key generation algorithm,
      which generates a public key pk and a secret key sk.

   *  Encaps(pk) -> (ct, ss): A probabilistic encapsulation algorithm,
      which takes as input a public key pk and outputs a ciphertext ct
      and shared secret ss.

   *  Decaps(sk, ct) -> ss: A decapsulation algorithm, which takes as
      input a secret key sk and ciphertext ct and outputs a shared
      secret ss, or in some cases a distinguished error value.


This document is not concerned with the KeyGen() algorithm of a KEM, but it is included above for completeness.

The KEM interface defined above differs from both traditional key transport mechanism (for example for use with KeyTransRecipientInfo defined in {{RFC5652}}), and key agreement (for example for use with KeyAgreeRecipientInfo defined in {{RFC5652}}). 

The KEM interface was chosen as the interface for a composite key exchange because it allows for arbitrary combinations of component algorithm types since both key transport and key agreement mechanisms can be promoted into KEMs in the following ways:

A key transport mechanism can be transformed into a KEM.Encaps(pk) by generating a random shared secret ss and performing KeyTrans.Encrypt(pk, ss) -> ct; and into a KEM.Decaps(sk, ct) by KeyTrans.Decrypt(sk, ct) -> ss. This follows the pattern of RSA-KEM [RFC5990].

A key agreement mechanism can be transformed into a KEM.Encaps(pk) by generating an ephemeral key pair (pk_e, sk_e), and performing KeyAgree(pk, sk_e) -> (ss, pk_e); and into a KEM.Decaps(sk, ct) by completing the key agreement as KeyAgree(pk_e, sk) -> ss.

A composite KEM allows two or more underlying key transport, key agreement, or KEM algorithms to be combined into a single cryptographic operations by performing each operation, transformed to a KEM as outline above, and using a specified combiner function to combine the two or more component shared secrets into a single shared secret.



The main security property for KEMs is indistinguishability under
adaptive chosen ciphertext attack (IND-CCA2), which means that shared
secret values should be indistinguishable from random strings even
given the ability to have other arbitrary ciphertexts decapsulated.

EDNOTE: it would be really nice for security proofs if definition of KEM included that the bits of the shared secret output need to be uniformly distributed (ie IND-CCA), because for example it would then be safe to XOR or truncate them. While the NIST PQC candidates all seem to do this, we could not find a definition of "KEM" that includes it as a requirement.


A weaker security notion is indistinguishability under chosen
plaintext attack (IND-CPA), which means that the shared secret values
should be indistinguishable from random strings given a copy of the
public key.  IND-CPA roughly corresponds to security against a
passive attacker, and sometimes corresponds to one-time key exchange.

The composite KEM mechanisms meets these security properties if and only if the component primitives meet them.

TODO: needs more formal analysis that the methods of transforming KeyTrans and KeyAgree meet this.

EDNOTE:  Discussed use of ASN.1 to combine the shared secrets. ASN.1 is nice because it embeds the length values for
us. Decided instead to run each component shared secret through the supplied KDF which will normalize all the lengths.

## Specifying Composite KEM Algorithms

The following is the mandatory to specify information when specifying a composite KEM type:

* An AlgorithmIdentifier OID for the composite KEM type.
* Component algorithms that will correspond to each position within the `CompositeCiphertextValue`. (see {{sec-CompositeCiphertextValue}}).
* A KEM combiner appropriate to the specific choice of component algorithms (see {{sec-kem-combiner}}).



TODO - LAMPS needs to define a KEM-ALGORITHM  -  extension to RFC 5912 - Bring to IETF. We just made up the prefix "kema" (for "KEM algorithm") is that the right prefix?   

~~~
kema-CompositeKEM KEM-ALGORITHM ::= {
    IDENTIFIER id-alg-composite-kem
    VALUE CompositeCiphertextValue
    PARAMS composite-kem-params  
    PUBLIC-KEYS { pk-Composite }
    SMIME-CAPS { IDENTIFIED BY id-alg-composite } }
}
~~~


## Composite Keys

A composite key is a single key object that performs an atomic cryptographic operation as
defined in {{I-D.ounsworth-pq-composite-keys}}.

### Key Usage Bits

When using composite KEM keys in a structure which defines a key usage (such as in an 
X509Certificate as defined in [RFC5280]), the following key usage MUST be used.

~~~
  keyEncipherment
~~~
   
Additional key usages SHOULD not be used.

EDNOTE:  The main argument for using keyEncipherment verses keyAgreement is that multiple 
parties are required to contribute to a key agreement verses a single party in keyEncipherment. 

EDNOTE:  It is recognized that KEMS will be added into other PKIX and X509 standards and LAMPS needs to make sure they all make the same choice about the key usage of a KEM key. 


## CompositeCiphertextValue {#sec-CompositeCiphertextValue}

The compositeCipherTextValue is a concatenation of the ciphertexts of the
underlying component algorithms.  It is represented in ASN.1 as follows:

~~~
CompositeCiphertextValue ::= SEQUENCE SIZE (2..MAX) OF BIT STRING
~~~

## Encoding Rules

Many protocol specifications will require that composite KEM data structures be represented by an octet string or bit string.

When an octet string is required, the DER encoding of the composite data structure SHALL be used directly.

EDNOTE: will this definition include an ASN.1 tag and length byte inside the OCTET STRING object? If so, that's probably an extra unnecessary layer.

When a bit string is required, the octets of the DER encoded composite data structure SHALL be used as the bits of the bit string, with the most significant bit of the first octet becoming the first bit, and so on, ending with the least significant bit of the last octet becoming the last bit of the bit string.

In the interests of simplicity and avoiding compatibility issues, implementations that parse these structures MAY accept both BER and DER.

## KEM Combiner {#sec-kem-combiner}

This document follows the advice of {{I-D.ounsworth-cfrg-kem-combiners}}: the outputs of multiple KEMs are combined as

TODO: Aron Wussler has a better version of the KEM combiner that should probably be rolled into {{I-D.ounsworth-cfrg-kem-combiners}} and then included here: `KMAC256(domainSeparation, 0x00000001 || K1 || K2 || fixedInfo, outputBits, “KDF”)`. TODO: update that doc, then take the new version here.

EDNOTE: should we add in a context string? Ex.: `KDF( "id-kem-Kyber512-ECDH-P256-SHAKE128" || H(ss1) || H(ss2) )`  ?

~~~
KDF( H(ss1) || H(ss2) )
~~~

where `||` represents concatenation.

Note that explicitly-defined algorithm combinations MAY opt to define the combiner without the inner hash on `H(ss1)` and `H(ss2)` the component KEMs use a KDF internally when producing its output.

Each registered composite KEM algorithm must specify the exact KEM combiner construction that is to be used.


Below we make the following pairings of kyber security level and KDF:

* Kyber512: shake128/256
* Kyber768: shake256/384
* Kyber1024 shake256/512


# Algorithm Identifiers {#sec-alg-ids}

This section defines algorithm identifiers, component algorithms and their ordering for composite combinations. The combinations registered in this section are intended to strike a balance between the overall number of combinations ("the combinatorial explosion problem"), while also covering the needs of a wide range of protocols, applications, and regulatory environments in which X.509-based technologies are used. 

This section is not intended to be exhaustive and other authors may define OIDs for new combinations so long as they are compatible with the structures and processes defined in this and the companion signature and encryption documents.


KEM type                                    | Definition                                         | OID
---------                                   | -----------                                        | ----------
id-Kyber512-ECDH-P256-shake128              | {{sec-id-Kyber512-ECDH-P256-SHAKE128}}             | TBD
id-Kyber512-ECDH-brainpoolP256r1-shake128   | {{sec-id-Kyber512-ECDH-brainpoolP256r1-shake128}}  | TBD
id-Kyber512-X25519-shake128                 | {{sec-id-Kyber512-X25519-shake128}}                | TBD
id-Kyber768-RSA-shake256                    | {{sec-id-Kyber768-RSA-shake256}}                   | TBD
id-Kyber768-ECDH-P256-shake256              | {{sec-id-Kyber768-ECDH-P256-shake256}}             | TBD
id-Kyber768-ECDH-brainpoolP256r1-shake256   | {{sec-id-Kyber768-ECDH-brainpoolP256r1-shake256}}  | TBD
id-Kyber768-X25519-shake256                 | {{sec-id-Kyber768-X25519-shake256}}                | TBD
id-Kyber1024-ECDH-P384-shake256             | {{sec-id-Kyber1024-ECDH-P384-shake256}}            | TBD
id-Kyber1024-ECDH-brainpoolP384r1-shake256  | {{sec-id-Kyber1024-ECDH-brainpoolP384r1-shake256}} | TBD
id-Kyber1024-X448-shake256                  | {{sec-id-Kyber1024-X448-shake256}}                 | TBD
id-composite-key-shake128          | {{sec-generic-composite-kem-shake128}}        | TBD
id-composite-key-shake256          | {{sec-generic-composite-kem-shake256}}        | TBD
{: #tab-kem-agls title="Composite KEM key types"}



These combinations were chosen according to the following rough guidelines:

1. One RSA combination is provided (but RSA modulus size not mandated), matched with NIST PQC Level 3 algorithms.
1. NIST [RFC6090], Edwards [RFC7748], and Brainpool [RFC5639] elliptic curve algorithms are provided. NIST PQC Levels 1 - 3 algorithms are matched with 256-bit curves, while NIST levels 4 - 5 are matched with 384-bit elliptic curves. This provides a balance between matching classical security levels of post-quantum and traditional algorithms, and also selecting elliptic curves which already have wide adoption.
1. NIST level 1 candidates (Kyber512) are provided, matched with 256-bit elliptic curves, intended for constrained use cases.
1. A generic composite OID is provided for implementers who wish to use combinations not listed here, without the overhead of defining new OIDs. Caution should be exercised to avoid issues with compatibility and complex cryptographic policy mechanisms.

The authors wish to note that although the CompositePublicKey and CompositePrivateKey structures are defined in such a way as to easily allow 3 or more component keys, it was decided at the time of writing to only specify explicit pairs. The generic composite algorithms specified in {{sec-generic-composite-kem-shake128}} and {{sec-generic-composite-kem-shake256}} of course allows for an arbitrary number of components. This also does not preclude future specification of explicit combinations with three or more components.


## id-Kyber512-ECDH-P256-SHAKE128 {#sec-id-Kyber512-ECDH-P256-SHAKE128}

This composite KEM algorithm MAY be used with a `id-Kyber512-ECDH-P256` composite key as defined in {{I-D.ounsworth-pq-composite-keys}}, or MAY be used with Kyber512 and EC P256 keys from independant sources, for example independant certificates, software or hardware keystores.

~~~
id-alg-composite-kem OBJECT IDENTIFIER ::= {
  joint-iso-itu-t(2) country(16) us(840) organization(1) 
  entrust(114027) Algorithm(80) ExplicitComposite(5) KEM5(2) 
  TBD }
~~~    

EDNOTE: this is a temporary OID for the purposes of prototyping.  We
   are requesting IANA to assign a permanent OID, see Section 6.

AlgorithmIdentifier paramaters are ABSENT.


The first componet BIT STRING within `CompositeCiphertextValue` SHALL be the 256-bit encapsulated key (ciphertext) of the Kyber512 algorithm as per TODO: cite NIST FIPS spec. `ss1` SHALL be the shared secret corresponding to the first ciphertext.


The second componet BIT STRING within `CompositeCiphertextValue` SHALL be the sender's secp256r1 public key as defied in [RFC5480]. `ss2` SHALL be the shared secret derived from applying Elliptic Curve Cryptography Cofactor Diffie-Hellman (ECC CDH) as defined in section 5.7.1.2 of [SP.800-56Ar3] to the other party's public key and one's own secp256r1 private key. SBecause this ECDH variant outputs directly the x coordinate of the shared point, we apply a hash function to extract a uniformly random secret from it.


The output of the two component KEMs is to be combined as follows:

~~~
ss = SHAKE128( ss1 || SHAKE128(ss2, 256) , 256)
~~~

where SHAKE128(M, 256) describes the use of the SHAKE128 as specified in [SHA3] with a 256 bit output.


## id-Kyber512-ECDH-brainpoolP256r1-shake128 {#sec-id-Kyber512-ECDH-brainpoolP256r1-shake128}

This composite KEM algorithm MAY be used with a `id-Kyber512-ECDH-brainpoolP256r1` composite key as defined in {{I-D.ounsworth-pq-composite-keys}}, or MAY be used with Kyber512 and EC P256 keys from independant sources, for example independant certificates, software or hardware keystores.

~~~
id-alg-composite-kem OBJECT IDENTIFIER ::= {
  joint-iso-itu-t(2) country(16) us(840) organization(1) 
  entrust(114027) Algorithm(80) TBD }
~~~    

EDNOTE: this is a temporary OID for the purposes of prototyping.  We
   are requesting IANA to assign a permanent OID, see Section 6.

AlgorithmIdentifier paramaters are ABSENT.


The first componet BIT STRING within `CompositeCiphertextValue` SHALL be the 256-bit encapsulated key (ciphertext) of the Kyber512 algorithm as per TODO: cite NIST FIPS spec. `ss1` SHALL be the shared secret corresponding to the first ciphertext.


The second componet BIT STRING within `CompositeCiphertextValue` SHALL be the the sender's brainpoolP256r1 public key as defied in [RFC5639]. `ss2` SHALL be the shared secret derived from applying the elliptic curve key agreement algorithm (ECKA) as defined in section 4.3.1 of [BSI-ECC] to the other party's public key and one's own brainpoolP256r1 private key. Note that [BSI-ECC] states: "The shared secret value Z_AB MUST NOT be used directly for encryption or integrity protection, key derivation functions are described in Section 4.3.3." and therefore, unlike the NIST ECDH variant, we concatenate `ss2` directly with `ss1`.


The output of the two component KEMs is to be combined as follows:

~~~
ss = SHAKE128( ss1 || ss2, 256)
~~~

where SHAKE128(M, 256) describes the use of the SHAKE128 as specified in [SHA3] with a 256 bit output.


## id-Kyber512-X25519-shake128 {#sec-id-Kyber512-X25519-shake128}

This composite KEM algorithm MAY be used with a `id-Kyber512-X25519` composite key as defined in {{I-D.ounsworth-pq-composite-keys}}, or MAY be used with Kyber512 and X25519 keys from independant sources, for example independant certificates, software or hardware keystores.

~~~
id-alg-composite-kem OBJECT IDENTIFIER ::= {
  joint-iso-itu-t(2) country(16) us(840) organization(1) 
  entrust(114027) Algorithm(80) TBD }
~~~    

EDNOTE: this is a temporary OID for the purposes of prototyping.  We
   are requesting IANA to assign a permanent OID, see Section 6.

AlgorithmIdentifier paramaters are ABSENT.


The first componet BIT STRING within `CompositeCiphertextValue` SHALL be the 256-bit encapsulated key (ciphertext) of the Kyber512 algorithm as per TODO: cite NIST FIPS spec. `ss1` SHALL be the shared secret corresponding to the first ciphertext.


The second componet BIT STRING within `CompositeCiphertextValue` SHALL be the sender's X25519 public key as defied in [RFC8410]. `ss2` SHALL be the shared secret derived from applying X25519 as defined in [RFC7748] to the other party's public key and one's own X25519 private key.


The output of the two component KEMs is to be combined as follows:

~~~
ss = SHAKE128( ss1 || ss2, 256)
~~~

where SHAKE128(M, 256) describes the use of the SHAKE128 as specified in [SHA3] with a 256 bit output.


## id-Kyber768-RSA-shake256 {#sec-id-Kyber768-RSA-shake256}


This composite KEM algorithm MAY be used with a `id-Kyber768-RSA` composite key as defined in {{I-D.ounsworth-pq-composite-keys}}, or MAY be used with Kyber768 and RSA keys from independant sources, for example independant certificates, software or hardware keystores.

~~~
id-alg-composite-kem OBJECT IDENTIFIER ::= {
  joint-iso-itu-t(2) country(16) us(840) organization(1) 
  entrust(114027) Algorithm(80) TBD }
~~~    

EDNOTE: this is a temporary OID for the purposes of prototyping.  We
   are requesting IANA to assign a permanent OID, see Section 6.

AlgorithmIdentifier paramaters are ABSENT.


--- BEGIN EDNOTE ---
TODO: this needs some thought. We probably want to just point to RSA-KEM RFC5990, but we don't have an existing key to transport, so we only need steps 1 - 3 as defined in RFC5990 A.2.

We need to carry the RSA-KEM params:


      GenericHybridParameters ::= {
         kem  KeyEncapsulationMechanism,
         dem  DataEncapsulationMechanism
      }


We should probably set the KDF params to implicitely to match the KEM combiner: KDF=SHAKE256, keyLength=384 and omit the params.

 RsaKemParameters ::= {
               keyDerivationFunction  KeyDerivationFunction,
               keyLength              KeyLength
            }

--- END EDNOTE ---

The first componet BIT STRING within `CompositeCiphertextValue` SHALL be the X-bit ?? (TODO: I assume it's 384?) encapsulated key (ciphertext) of the Kyber768 algorithm as per TODO: cite NIST FIPS spec. `ss1` SHALL be the shared secret corresponding to the first ciphertext.


The second componet BIT STRING within `CompositeCiphertextValue` SHALL be the ciphertext `C` as defined in [RFC5990] appendix A.2. `ss2` SHALL be the shared secret `Z` as defined in [RFC5990]. Since `Z` variant is directly a field element, we need to mask it with a KDF prior to combining it with the other shared secret.


The output of the two component KEMs is to be combined as follows:

~~~
ss = SHAKE256( ss1 || SHAKE256(ss2, 384), 384)
~~~

where SHAKE256(M, 384) describes the use of the SHAKE256 as specified in [SHA3] with a 384 bit output.



## id-Kyber768-ECDH-P256-shake256 {#sec-id-Kyber768-ECDH-P256-shake256}

This composite KEM algorithm MAY be used with a `id-Kyber768-ECDH-P256` composite key as defined in {{I-D.ounsworth-pq-composite-keys}}, or MAY be used with Kyber768 and EC P256 keys from independant sources, for example independant certificates, software or hardware keystores.

~~~
id-alg-composite-kem OBJECT IDENTIFIER ::= {
  joint-iso-itu-t(2) country(16) us(840) organization(1) 
  entrust(114027) Algorithm(80) ExplicitComposite(5) KEM5(2) 
  TBD }
~~~    

EDNOTE: this is a temporary OID for the purposes of prototyping.  We
   are requesting IANA to assign a permanent OID, see Section 6.

AlgorithmIdentifier paramaters are ABSENT.


The first componet BIT STRING within `CompositeCiphertextValue` SHALL be the X-bit ?? (TODO: I assume it's 384?) encapsulated key (ciphertext) of the Kyber768 algorithm as per TODO: cite NIST FIPS spec. `ss1` SHALL be the shared secret corresponding to the first ciphertext.


The second componet BIT STRING within `CompositeCiphertextValue` SHALL be the sender's secp256r1 public key as defied in [RFC5480]. `ss2` SHALL be the shared secret derived from applying Elliptic Curve Cryptography Cofactor Diffie-Hellman (ECC CDH) as defined in section 5.7.1.2 of [SP.800-56Ar3] to the other party's public key and one's own secp256r1 private key. Because this ECDH variant outputs directly the x coordinate of the shared point, we apply a hash function to extract a uniformly random secret from it.


The output of the two component KEMs is to be combined as follows:

~~~
ss = SHAKE256( ss1 || SHAKE256(ss2, 384), 384)
~~~

where SHAKE256(M, 384) describes the use of the SHAKE256 as specified in [SHA3] with a 384 bit output.


## id-Kyber768-ECDH-brainpoolP256r1-shake256 {#sec-id-Kyber768-ECDH-brainpoolP256r1-shake256}

This composite KEM algorithm MAY be used with a `id-Kyber768-ECDH-brainpoolP256r1` composite key as defined in {{I-D.ounsworth-pq-composite-keys}}, or MAY be used with Kyber768 and EC P256 keys from independant sources, for example independant certificates, software or hardware keystores.

~~~
id-alg-composite-kem OBJECT IDENTIFIER ::= {
  joint-iso-itu-t(2) country(16) us(840) organization(1) 
  entrust(114027) Algorithm(80) TBD }
~~~    

EDNOTE: this is a temporary OID for the purposes of prototyping.  We
   are requesting IANA to assign a permanent OID, see Section 6.

AlgorithmIdentifier paramaters are ABSENT.


The first componet BIT STRING within `CompositeCiphertextValue` SHALL be the X-bit ?? (TODO: I assume it's 384?) encapsulated key (ciphertext) of the Kyber768 algorithm as per TODO: cite NIST FIPS spec. `ss1` SHALL be the shared secret corresponding to the first ciphertext.


The second componet BIT STRING within `CompositeCiphertextValue` SHALL be the the sender's brainpoolP256r1 public key as defied in [RFC5639]. `ss2` SHALL be the shared secret derived from applying the elliptic curve key agreement algorithm (ECKA) as defined in section 4.3.1 of [BSI-ECC] to the other party's public key and one's own brainpoolP256r1 private key. Note that [BSI-ECC] states: "The shared secret value Z_AB MUST NOT be used directly for encryption or integrity protection, key derivation functions are described in Section 4.3.3." and therefore, unlike the NIST ECDH variant, we concatenate `ss2` directly with `ss1`.


The output of the two component KEMs is to be combined as follows:

~~~
ss = SHAKE256( ss1 || ss2, 384)
~~~

where SHAKE256(M, 384) describes the use of the SHAKE256 as specified in [SHA3] with a 384 bit output.


## id-Kyber768-X25519-shake256 {#sec-id-Kyber768-X25519-shake256}

This composite KEM algorithm MAY be used with a `id-Kyber768-X25519` composite key as defined in {{I-D.ounsworth-pq-composite-keys}}, or MAY be used with Kyber768 and X25519 keys from independant sources, for example independant certificates, software or hardware keystores.

~~~
id-alg-composite-kem OBJECT IDENTIFIER ::= {
  joint-iso-itu-t(2) country(16) us(840) organization(1) 
  entrust(114027) Algorithm(80) TBD }
~~~    

EDNOTE: this is a temporary OID for the purposes of prototyping.  We
   are requesting IANA to assign a permanent OID, see Section 6.

AlgorithmIdentifier paramaters are ABSENT.


The first componet BIT STRING within `CompositeCiphertextValue` SHALL be the X-bit ?? (TODO: I assume it's 384?) encapsulated key (ciphertext) of the Kyber768 algorithm as per TODO: cite NIST FIPS spec. `ss1` SHALL be the shared secret corresponding to the first ciphertext.


The second componet BIT STRING within `CompositeCiphertextValue` SHALL be the sender's X25519 public key as defied in [RFC8410]. `ss2` SHALL be the shared secret derived from applying X25519 as defined in [RFC7748] to the other party's public key and one's own X25519 private key.


The output of the two component KEMs is to be combined as follows:

~~~
ss = SHAKE256( ss1 || ss2, 384)
~~~

where SHAKE256(M, 384) describes the use of the SHAKE256 as specified in [SHA3] with a 384 bit output.


## id-Kyber1024-ECDH-P384-shake256 {#sec-id-Kyber1024-ECDH-P384-shake256}


This composite KEM algorithm MAY be used with a `id-Kyber1024-ECDH-P384` composite key as defined in {{I-D.ounsworth-pq-composite-keys}}, or MAY be used with Kyber768 and EC P256 keys from independant sources, for example independant certificates, software or hardware keystores.

~~~
id-alg-composite-kem OBJECT IDENTIFIER ::= {
  joint-iso-itu-t(2) country(16) us(840) organization(1) 
  entrust(114027) Algorithm(80) ExplicitComposite(5) KEM5(2) 
  TBD }
~~~    

EDNOTE: this is a temporary OID for the purposes of prototyping.  We
   are requesting IANA to assign a permanent OID, see Section 6.

AlgorithmIdentifier paramaters are ABSENT.


The first componet BIT STRING within `CompositeCiphertextValue` SHALL be the X-bit ?? (TODO: I assume it's 512?) encapsulated key (ciphertext) of the Kyber768 algorithm as per TODO: cite NIST FIPS spec. `ss1` SHALL be the shared secret corresponding to the first ciphertext.


The second componet BIT STRING within `CompositeCiphertextValue` SHALL be the sender's secp384r1 public key as defied in [RFC5480]. `ss2` SHALL be the shared secret derived from applying Elliptic Curve Cryptography Cofactor Diffie-Hellman (ECC CDH) as defined in section 5.7.1.2 of [SP.800-56Ar3] to the other party's public key and one's own secp384r1 private key. Because this ECDH variant outputs directly the x coordinate of the shared point, we apply a hash function to extract a uniformly random secret from it.


The output of the two component KEMs is to be combined as follows:

~~~
ss = SHAKE256( ss1 || SHAKE256(ss2, 512), 512)
~~~

where SHAKE256(M, 512) describes the use of the SHAKE256 as specified in [SHA3] with a 512 bit output.


## id-Kyber1024-ECDH-brainpoolP384r1-shake256 {#sec-id-Kyber1024-ECDH-brainpoolP384r1-shake256}

This composite KEM algorithm MAY be used with a `id-Kyber1024-ECDH-brainpoolP384r1` composite key as defined in {{I-D.ounsworth-pq-composite-keys}}, or MAY be used with Kyber768 and EC P256 keys from independant sources, for example independant certificates, software or hardware keystores.

~~~
id-alg-composite-kem OBJECT IDENTIFIER ::= {
  joint-iso-itu-t(2) country(16) us(840) organization(1) 
  entrust(114027) Algorithm(80) TBD }
~~~    

EDNOTE: this is a temporary OID for the purposes of prototyping.  We
   are requesting IANA to assign a permanent OID, see Section 6.

AlgorithmIdentifier paramaters are ABSENT.


The first componet BIT STRING within `CompositeCiphertextValue` SHALL be the X-bit ?? (TODO: I assume it's 384?) encapsulated key (ciphertext) of the Kyber768 algorithm as per TODO: cite NIST FIPS spec. `ss1` SHALL be the shared secret corresponding to the first ciphertext.

The second componet BIT STRING within `CompositeCiphertextValue` SHALL be the the sender's brainpoolP384r1 public key as defied in [RFC5639]. `ss2` SHALL be the shared secret derived from applying the elliptic curve key agreement algorithm (ECKA) as defined in section 4.3.1 of [BSI-ECC] to the other party's public key and one's own brainpoolP384r1 private key. Note that [BSI-ECC] states: "The shared secret value Z_AB MUST NOT be used directly for encryption or integrity protection, key derivation functions are described in Section 4.3.3." and therefore, unlike the NIST ECDH variant, we concatenate `ss2` directly with `ss1`.


The output of the two component KEMs is to be combined as follows:

~~~
ss = SHAKE256( ss1 || ss2, 512)
~~~

where SHAKE256(M, 512) describes the use of the SHAKE256 as specified in [SHA3] with a 512 bit output.


## id-Kyber1024-X448-shake256 {#sec-id-Kyber1024-X448-shake256}

This composite KEM algorithm MAY be used with a `id-Kyber1024-X448` composite key as defined in {{I-D.ounsworth-pq-composite-keys}}, or MAY be used with Kyber1024 and X448 keys from independant sources, for example independant certificates, software or hardware keystores.

~~~
id-alg-composite-kem OBJECT IDENTIFIER ::= {
  joint-iso-itu-t(2) country(16) us(840) organization(1) 
  entrust(114027) Algorithm(80) TBD }
~~~    

EDNOTE: this is a temporary OID for the purposes of prototyping.  We
   are requesting IANA to assign a permanent OID, see Section 6.

AlgorithmIdentifier paramaters are ABSENT.


The first componet BIT STRING within `CompositeCiphertextValue` SHALL be the X-bit ?? (TODO: I assume it's 512?) encapsulated key (ciphertext) of the Kyber1024 algorithm as per TODO: cite NIST FIPS spec. `ss1` SHALL be the shared secret corresponding to the first ciphertext.


The second componet BIT STRING within `CompositeCiphertextValue` SHALL be the sender's X448 public key as defied in [RFC8410]. `ss2` SHALL be the shared secret derived from applying X448 as defined in [RFC7748] to the other party's public key and one's own X448 private key.


The output of the two component KEMs is to be combined as follows:

~~~
ss = SHAKE256( ss1 || SHAKE256(ss2, 512), 512)
~~~

where SHAKE256(M, 512) describes the use of the SHAKE256 as specified in [SHA3] with a 512 bit output.



## id-alg-composite-kem-shake128 {#sec-generic-composite-kem-shake128}

The `id-alg-composite-kem-SHAKE128` object identifier is used for identifying a generic composite KEM algorithm. This allows arbitrary combinations of component key transport, key agreement and KEM algorithms without needing the combination to be pre-registered or standardized. This generic KEM composite algorithm uses SHAKE128 as the KEM combiner and so is intended for use with component KEM algorithms that target the 128 bit security level. For combining KEM algorithms at higher security levels, it is recommended to use `id-alg-composite-kem-shake256` defined in {{sec-generic-composite-kem-shake256}}.


~~~
id-alg-composite-kem-SHAKE128 OBJECT IDENTIFIER ::= {
  joint-iso-itu-t(2) country(16) us(840) organization(1) 
  entrust(114027) Algorithm(80) Composite(4) KEM (5) }
~~~

EDNOTE: this is a temporary OID for the purposes of prototyping.  We
   are requesting IANA to assign a permanent OID, see Section 6.



EDNOTE: does the (generic) params need to also carry a list of AlgorithmIdentifiers that were used in the encryption? With signatures we need this to prevent the verifier from coming up with false validity by using the wrong verification algorithm(s). With encryption I think it's less important because either your private key works or it doesn't, no harm done by trying to decrypt with the wrong alg. So the question is: is it useful as a hint to the decrypter?


This composite KEM algorithm MAY be used with a `id-composite-key` composite key as defined in {{I-D.ounsworth-pq-composite-keys}}, prodived that it carries a carries a `keyUsage` of `keyEncipherment` or `keyAgreement` and contains component keys of corresponding approriate types. This composite KEM algorithm MAY also be used with `keyEncipherment` or `keyAgreement` type keys from independant sources, for example independant certificates, software or hardware keystores.


When using this generic composite mode, the application is responsible for determining the contents and order of the `CompositeCihprtextValue`s. 

In general we do not know if it is safe to use the component shared secrets directly, so we wrap both with a KDF in the following KEM combiner:

~~~
ss = SHAKE128( SHAKE128(ss1, 256) || SHAKE128(ss2, 256) , 256)
~~~

where SHAKE128(M, 256) describes the use of the SHAKE128 as specified in [SHA3] with a 256 bit output.


## id-alg-composite-kem-shake256 {#sec-generic-composite-kem-shake256}

The id-alg-composite-kem object identifier is used for identifying a generic composite KEM algorithm. This allows arbitrary combinations of component key transport, key agreement and KEM algorithms without needing the combination to be pre-registered or standardized. 


~~~
id-alg-composite-kem OBJECT IDENTIFIER ::= {
  joint-iso-itu-t(2) country(16) us(840) organization(1) 
  entrust(114027) Algorithm(80) Composite(4) KEM (??) }
~~~

EDNOTE: this is a temporary OID for the purposes of prototyping.  We
   are requesting IANA to assign a permanent OID, see Section 6.

TODO: update the Entrust registry to make this `KEM-SHAKE128 / KEM-SHAKE256`.



EDNOTE: does the (generic) params need to also carry a list of AlgorithmIdentifiers that were used in the encryption? With signatures we need this to prevent the verifier from coming up with false validity by using the wrong verification algorithm(s). With encryption I think it's less important because either your private key works or it doesn't, no harm done by trying to decrypt with the wrong alg. So the question is: is it useful as a hint to the decrypter?


This composite KEM algorithm MAY be used with a `id-composite-key` composite key as defined in {{I-D.ounsworth-pq-composite-keys}}, prodived that it carries a carries a `keyUsage` of `keyEncipherment` or `keyAgreement` and contains component keys of corresponding approriate types. This composite KEM algorithm MAY also be used with `keyEncipherment` or `keyAgreement` type keys from independant sources, for example independant certificates, software or hardware keystores.


When using this generic composite mode, the application is responsible for determining the contents and order of the `CompositeCihprtextValue`s. 

In general we do not know if it is safe to use the component shared secrets directly, so we wrap both with a KDF in the following KEM combiner:

~~~
ss = SHAKE256( SHAKE256(ss1, 512) || SHAKE256(ss2, 512) , 512)
~~~

where SHAKE256(M, 512) describes the use of the SHAKE256 as specified in [SHA3] with a 512 bit output.



# In Practice {#sec-in-pract}

This section addresses practical issues of how this draft affects other protocols and standards.


EDNOTE 10: Possible topics to address:

  - The size of these certs and cert chains.
  - In particular, implications for (large) composite keys / signatures / certs on the handshake stages of TLS and IKEv2.
  - If a cert in the chain is a composite cert then does the whole chain need to be of composite Certs?
  - We could also explain that the root CA cert does not have to be of the same algorithms. The root cert SHOULD NOT be transferred in the authentication exchange to save transport overhead and thus it can be different than the intermediate and leaf certs.
  - We could talk about overhead (size and processing).
  - We could also discuss backwards compatibility.
  - We could include a subsection about implementation considerations.



## Backwards Compatibility {#sec-backwards-compat}

As noted in the introduction, the post-quantum cryptographic migration will face challenges in both ensuring cryptographic strength against adversaries of unknown capabilities, as well as providing ease of migration. The composite mechanisms defined in this document primarily address cryptographic strength, however this section contains notes on how backwards compatibility may be obtained.

The term "ease of migration" is used here to mean that existing systems can be gracefully transitioned to the new technology without requiring large service disruptions or expensive upgrades. The term "backwards compatibility" is used here to mean something more specific; that existing systems as they are deployed today can interoperate with the upgraded systems of the future.

These migration and interoperability concerns need to be thought about in the context of various types of protocols that make use of X.509 and PKIX with relation to key establishment and content encryption, from online negotiated protocols such as TLS 1.3 [RFC8446] and IKEv2 [RFC7296], to non-negotiated asynchronous protocols such as S/MIME signed email [RFC8551], as well as myriad other standardized and proprietary protocols and applications that leverage CMS [RFC5652] encrypted structures.

### K-of-N modes

~~~ BEGIN EDNOTE ~~~
In the context of encryption, K-of-N modes could mean one of two things:

Type 1: sender uses a subset

This would mean the sender (encrypter) uses a subset of K the N component keys within the receiver's public key. The obvious way to combine them is with skipping the unused keys / algorithms and emitting a NULL ciphertext in their place. This mechanism is straight-forward and allows ease of migration where a sender encounters a composite encryption public key where it does not support all component algorithms. It also supports performance optimization where, for example, a receiver can be issued a key with many component keys and a sender can choose the highest-performance subset that are still considered safe.


Type 2: receiver uses a subset

This would mean that the sender (encrypter) uses all N of the component keys within the receiver's public key in such a way that the receiver (decrypter) only needs to use K private keys to decrypt the message. This implies the need for some kind of Shamir's-like secret splitting scheme. This is a reasonably complex mechanism and it's currently unclear if there are any use-cases that require such a mechanism.

~~~ END EDNOTE ~~~


### Parallel PKIs

We present the term "Parallel PKI" to refer to the setup where a PKI end entity possesses two or more distinct public keys or certificates for the same identity (name), but containing keys for different cryptographic algorithms. One could imagine a set of parallel PKIs where an existing PKI using legacy algorithms (RSA, ECC) is left operational during the post-quantum migration but is shadowed by one or more parallel PKIs using pure post quantum algorithms or composite algorithms (legacy and post-quantum).

Equipped with a set of parallel public keys in this way, a client would have the flexibility to choose which public key(s) or certificate(s) to use in a given signature operation. 

For negotiated protocols, the client could choose which public key(s) or certificate(s) to use based on the negotiated algorithms.

For non-negotiated protocols, the details for obtaining backwards compatibility will vary by protocol, but for example in CMS [RFC5652].

EDNOTE: I copied and pruned this text from {{I-D.ounsworth-pq-composite-sigs}}. It probably needs to be fleshed out more as we better understand the implementation concerns around composite encryption.

<!-- End of In Practice section -->

# IANA Considerations {#sec-iana}
The ASN.1 module OID is TBD.  


<!-- End of IANA Considerations section -->


# Security Considerations


## Policy for Deprecated and Acceptable Algorithms

Traditionally, a public key, certificate, or signature contains a single cryptographic algorithm. If and when an algorithm becomes deprecated (for example, RSA-512, or SHA1), it is obvious that structures using that algorithm are implicitly revoked.

In the composite model this is less obvious since implementers may decide that certain cryptographic algorithms have complementary security properties and are acceptable in combination even though one or both algorithms are deprecated for individual use. As such, a single composite public key, certificate, signature, or ciphertext may contain a mixture of deprecated and non-deprecated algorithms. 

Specifying behaviour in these cases is beyond the scope of this document, but should be considered by Implementers and potentially in additional standards.

EDNOTE: Max is working on a CRL mechanism to accomplish this.

## OR Modes

TODO -- we'll need security consideration analysis of whatever OR modes we choose.


## Cryptographic review of combiner

EDNOTE: LAMPS should probably request CFRG review of this draft to ensure that the combiner is resistant to all known cryptographic attacks.

### Need for a KDF within the combiner

It is expected that the majority of uses of the KEM defined in this document will be within a construct such as {{I-D.perret-prat-lamps-cms-pq-kem}} which supplies the KEM output to a KDF in order to derive a wrapping key. In these cases it is redundant for the combiner within the composite KEM to also use a KDF. However, it is possible for protocol designers to want to use a KEM output -- or a truncation of it -- directly as a symmetric key; for this purpose we have included a KDF in the composite KEM construction.

In protocols where the KEM output will be supplied to a KDF, it should be safe to use a NULL KDF within the composite KEM -- ie the KDF where `KDF(m) = m` -- but we leave the details of any such security analysis to the protocol designers who wish to implement it.

### APOP Attack on concatenated keys {#sec-apop-attack}

See the attack analysis described in summary in [Aviram2021].

The pre-conditions for the described attack are quite strong: namely that the attacker has full control of both the content and length of the first shared secret in the combiner, and that the attacker can perform collision attacks against the underlying KDF.

We believe that, in general, neither of these pre-conditions are met within PKIX protocols. First, any key transport, key agreement, or KEM primitive approved for use within PKIX sets a fixed length for the shared secret that it produces so that the attacker cannot change the shared secret length between subsequent runs of the same protocol. This justification aligns with the justification used for {{I-D.ietf-tls-hybrid-design}}. Second, any non-deprecated KDF will not allow collision attacks.

In addition, the combiner construction defined in this document aims to provide additional collision resistance on top of that provided by the underlying KDF.



### Aviram2022

See the attack analysis described in summary in [Aviram2022].


This paper is largely critiquing the use of HKDF (HMAC) as a dual-PRF combiner for two secrets. This is not exactly what we are doing here.

[Aviram2022] gives the following definition:
"If we would like to combine two keys, either of which might be influenced by an attacker, we need a dual-PRF as the keycombiner: That is, a function which is a PRF when keyed by either input.

We believe the construction offered in this document meets this definition of a dual-PRF so long as the chosen KDF is itself a PRF. This holds even if the chosen KDF is HKDF with the same key (salt) used in each KDF() operation.

<!-- End of Security Considerations section -->

--- back

# Examples {#appdx-examples}

TBD

# ASN.1 Module

TBD -- UPDATE

~~~ ASN.1

<CODE STARTS>

Composite-Keys-2022
  { TBD }

DEFINITIONS IMPLICIT TAGS ::= BEGIN

EXPORTS ALL;

IMPORTS
-- any?

--
-- Object Identifiers
--

-- To be replaced by IANA
id-alg-composite-kem OBJECT IDENTIFIER ::= {
joint-iso-itu-t(2) country(16) us(840) organization(1) 
entrust(114027) Algorithm(80) Composite(4) KEM (5) }

id-composite-kdf-combiner OBJECT IDENTIFIER ::= { TBD }


--
-- Composite structures
--

CompositeCiphertextValue ::= SEQUENCE SIZE (2..MAX) OF BIT STRING

kema-CompositeKEM KEM-ALGORITHM ::= {
    IDENTIFIER id-alg-composite-kem
    VALUE CompositeCiphertextValue
    PARAMS composite-kem-params  
    PUBLIC-KEYS { pk-Composite }
    SMIME-CAPS { IDENTIFIED BY id-alg-composite } }
}

TODO: this assumes that KEM-ALGORITHM is defined, which it currently is not.

composite-kem-params  ::= {
    combiner     AlgorithmIdentifier
}

alg-composite-kdf-combiner-params ::= {
        kdf     AlgorithmIdentifier
}

END

<CODE ENDS>

~~~


# Intellectual Property Considerations

The following IPR Disclosure relates to this draft:

https://datatracker.ietf.org/ipr/3588/

EDNOTE:   I don't think this applies to this draft.



# Contributors and Acknowledgements
This document incorporates contributions and comments from a large group of experts. The Editors would especially like to acknowledge the expertise and tireless dedication of the following people, who attended many long meetings and generated millions of bytes of electronic mail and VOIP traffic over the past year in pursuit of this document:

Serge Mister (Entrust), Ali Noman (Entrust), Scott Fluhrer (Cisco), Jan Klaußner (D-Trust), Max Pala (CableLabs), and
Douglas Stebila (University of Waterloo).

We are grateful to all, including any contributors who may have
been inadvertently omitted from this list.

This document borrows text from similar documents, including those referenced below. Thanks go to the authors of those
   documents.  "Copying always makes things easier and less error prone" - [RFC8411].

## Making contributions

Additional contributions to this draft are welcome. Please see the working copy of this draft at, as well as open issues at:

https://github.com/EntrustCorporation/draft-composite-kem/


<!-- End of Contributors section -->
